#!/usr/bin/env python3

import os
import sys
import pyshark
import dpkt
import argparse
import base64
import binascii
import logging
import json
import struct
from collections import OrderedDict
from urllib.parse import urlparse
from Crypto.Hash import SHA
from Crypto.Cipher import ARC4


class FormbookUtils:

    fb_browsers = [
        "I-explorer", "Firefox", "Chrome", "Ms-Edge",
        "Tor", "Opera", "Safari", "Torch", "Q-360",
        "Maxthon", "sMonkey", "Avant", "Deepnet",
        "C-dragon", "safeZone", "360", "Titan", "Icedragon",
        "Baidu", "Yandex", "Canary", "Chromium", "K-Meleon",
        "Rambler", "Browzar", "BlackHawk", "Citrio", "CoolNovo", "Coowon",
        "Cyberfox", "Dooble", "Vivaldi", "Iridium", "Lunascape",
        "Epic", "Midori", "Mustang", "Orbitum", "PaleMoon",
        "QT-Web", "QupZilla", "Sleipnir", "Superbird",
        "UC", "Waterfox"
     ]

    # a small character substitution routine is called on
    # base64 encoded parameters before sending request
    b64_trans_dict = {
        '-': '+', '_': '/', '.': '=',
        '~': '+', '(': '/', ')': '=',
        ' ': '+'
    }

    @staticmethod
    def b64_trans(encoded_str):
        return ''.join([
            FormbookUtils.b64_trans_dict[c]
            if c in FormbookUtils.b64_trans_dict
            else c for c in encoded_str
        ])

    @staticmethod
    def get_browser_from_br_id(br):
        if br >= 0 and br < 6:
            br_idx = br
        elif br > 15 and br < 64:
            br_idx = br - 11
        else:
            br_idx = None
        if br_idx is not None and br_idx < len(FormbookUtils.fb_browsers):
            browser = FormbookUtils.fb_browsers[br_idx]
        else:
            browser = 'Unknown'
        return browser

    @staticmethod
    def sha1_revert(digest):
        tuples = struct.unpack("<IIIII", digest)
        output_hash = bytes()
        for item in tuples:
            output_hash += struct.pack(">I", item)
        return output_hash

    @staticmethod
    def formbook_compute_sha1(input_buffer):
        sha1 = SHA.new()
        sha1.update(input_buffer.encode('utf-8'))
        return FormbookUtils.sha1_revert(sha1.digest())


class FormbookMessage():
    def __init__(self, fb_http_req):
        self.pkt_number = fb_http_req.pkt_number
        self.http_request = True
        self.http_method = fb_http_req.method
        self.http_host = fb_http_req.host
        self.uri_base = fb_http_req.uri_base

    def toJSON(self):
        return json.dumps(
            self, default=lambda o: o.__dict__,
            sort_keys=False, indent=4
        )

    def __str__(self):
        return self.toJSON()


class FormbookBeaconingMessage(FormbookMessage):
    def __init__(self, fb_http_req, data):
        super().__init__(fb_http_req)
        self.beaconing = type('beaconing', (object,), {})()
        data = str(data, 'utf-8')
        args = data.split(':')
        if len(args) >= 4:
            magic = args[0]  # 'FBNG' header
            self.beaconing.username = str(base64.b64decode(args[3]), 'utf-8')
            self.beaconing.sid_crc = args[1][:8]
            self.beaconing.version = args[1][8:]
            self.beaconing.windows_version = args[2]


class FormbookFormMessage(FormbookMessage):
    def __init__(self, fb_http_req, un, br_id, data):
        super().__init__(fb_http_req)
        self.form = type('form', (object,), {})()
        self.form.un = un
        self.form.br_id = br_id
        self.form.browser = FormbookUtils.get_browser_from_br_id(br_id)
        try:
            self.form.payload_utf8 = str(data, 'utf-8')
        except UnicodeDecodeError:  # The incoming data encoding can't be guessed
            self.form.payload_utf8 = None
        self.form.payload_b64 = str(base64.b64encode(data), 'utf-8')


class FormbookScreenshotMessage(FormbookMessage):
    def __init__(self, fb_http_req, un, br_id, data):
        super().__init__(fb_http_req)
        self.screenshot = type('screenshot', (object,), {})()
        self.screenshot.username = un
        self.screenshot.br_id = br_id
        if len(data) >= 20 and data.startswith(b'FBIMG'):
            self.screenshot.sid_crc = str(data[5:13], 'utf-8')
            screen_name = 'fb_screen_{}.jpeg'.format(self.pkt_number)
            screen_path = os.path.join(args.dump_directory, screen_name)
            with open(screen_path, 'wb') as img:
                img.write(data[13:])
            self.screenshot.screen_path = screen_path


# Keystroke, Clipboard, Password recoveries and sniff
class FormbookKeystrokeMessage(FormbookMessage):
    def __init__(self, fb_http_req, un, br_id, data):
        super().__init__(fb_http_req)
        self.keylog_sniff_recoveries = type('keystroke', (object,), {})()
        self.keylog_sniff_recoveries.username = un
        self.keylog_sniff_recoveries.br_id = br_id
        self.keylog_sniff_recoveries.payload = data.decode('utf-16')


def FormbookUnhandleMessage(br, data):
    def __init__(self, fb_http_req, un, br_id, data):
        super().__init__(fb_http_req)
    logging.warning('Message {} is not yet implemented'.format(br), extra={'pkt': fb_http_req.pkt_num})


class FormbookPostDataHandler():

    formbook_data_handler = [
        FormbookFormMessage,  # I-explorer
        FormbookFormMessage,  # Firefox
        FormbookFormMessage,  # Chrome
        FormbookFormMessage,  # Ms-Edge
        FormbookFormMessage,  # Tor
        FormbookFormMessage,  # Opera
        FormbookUnhandleMessage,
        FormbookUnhandleMessage,
        FormbookScreenshotMessage,
        FormbookKeystrokeMessage
    ]

    @staticmethod
    def handle_data(fb_http_req, un, br, data):
        if br >= 0 and br < len(FormbookPostDataHandler.formbook_data_handler):
            return FormbookPostDataHandler.formbook_data_handler[br](fb_http_req, un, br, data)
        elif br > 15 and br < 64:
            return FormbookFormMessage(un, br, data)
        else:
            logging.warning('Unknow br value {} in POST request'.format(br), extra={'pkt': fb_http_req.pkt_number})
            return FormbookMessage(fb_http_req)


class FormbookHTTPRequest(dpkt.http.Request):
    def __init__(self, http_raw_payload, pkt_number):
        super().__init__(http_raw_payload)
        self.pkt_number = pkt_number

    def parse_common_headers(self):
        self.url = urlparse(self.uri)
        self.host = self.headers['host']
        self.uri_base = self.host + self.url.path  # e.g "www.preferedpopcorn.com/putty/support/fren/"
        self.rc4_key = FormbookUtils.formbook_compute_sha1(self.uri_base)

    def is_formbook_get_request(self):
        if self.method != 'GET' or len(self.headers) != 2:
            return False
        hdrs = list(self.headers.items())
        test_hdrs = hdrs[0][0] == 'host' and \
            hdrs[1] == ('connection', 'close')
        return test_hdrs

    def is_formbook_post_request(self):
        if self.method != 'POST' or len(self.headers) != 11:
            return False
        hdrs = list(self.headers.items())
        test_hdrs = hdrs[0][0] == 'host' and \
            hdrs[1] == ('connection', 'close') and \
            hdrs[2][0] == 'content-length' and \
            hdrs[3] == ('cache-control', 'no-cache') and \
            hdrs[4] == ('origin', 'http://' + self.headers['host']) and \
            hdrs[5][0] == ('user-agent') and \
            hdrs[6] == ('content-type', 'application/x-www-form-urlencoded') and \
            hdrs[7] == ('accept', '*/*') and \
            hdrs[8][0] == 'referer' and \
            hdrs[9] == ('accept-language', 'en-US') and \
            hdrs[10] == ('accept-encoding', 'gzip, deflate')
        return test_hdrs

    def formbook_decode_request(self):
        if self.is_formbook_get_request():
            self.parse_common_headers()
            return self.formbook_decode_get()
        elif self.is_formbook_post_request():
            self.parse_common_headers()
            return self.formbook_decode_post()

    def formbook_decode_get(self):
        params = self.url.query.split('&')
        for p in params:  # args order is random
            key, value = p.split('=', 1)
            try:
                encrypted = base64.b64decode(value)
                decrypted = ARC4.new(self.rc4_key).decrypt(encrypted)
                if decrypted.startswith(b'FBNG'):
                    return FormbookBeaconingMessage(self, decrypted)
            except binascii.Error:  # fake args are not base64 compliants
                pass

    def formbook_decode_post(self):
        null_byte_pos = self.body.find(b'\x00')  # formbook may append NULL bytes after the HTTP body
        if null_byte_pos != -1:
            body = self.body[:null_byte_pos]
        else:
            body = self.body
        body = body.decode('utf-8')

        fake_key, encrypted_params = body.split('=', 1)
        encrypted_params = FormbookUtils.b64_trans(encrypted_params)
        try:
            params = ARC4.new(self.rc4_key).decrypt(base64.b64decode(encrypted_params))
            params = params.decode('utf-8')
        except UnicodeDecodeError as e:  # junk bytes may appears after 'br=<digit>' parameter
            params = params[:e.start].decode('utf-8')

        br = un = data = None
        for p in params.split('&'):
            key, value = p.split('=', 1)
            value = FormbookUtils.b64_trans(value)
            if key == 'un':
                un = str(base64.b64decode(value), 'utf-8')
            elif key == 'br':
                br = int(value[0])
            elif key == 'dat':
                data = ARC4.new(self.rc4_key).decrypt(base64.b64decode(value))
            else:
                logging.warning('Unknow key \'{}\' in POST request'.format(key), extra={'pkt': self.pkt_number})
        return FormbookPostDataHandler.handle_data(self, un, br, data)


class FormbookPcapAnalyzer():
    def __init__(self, args):
        self.cap = pyshark.FileCapture(args.pcap, keep_packets=False)
        self.dump_directory = args.dump_directory
        if not os.path.exists(self.dump_directory):
            os.mkdir(self.dump_directory)

    def extract_http_request(self, pkt):
        layer_index = 0
        for l in pkt.layers:
            if l.layer_name == 'http':
                previous_layer_name = pkt.layers[layer_index - 1].layer_name
                if previous_layer_name == 'tcp' or previous_layer_name == 'data':
                    if l.get_field('request'):  # is it an HTTP request ?
                        tcp_layer = pkt.layers[layer_index - 1]
                        if 'tcp_reassembled_data' in tcp_layer.field_names:
                            http_raw_payload = tcp_layer.tcp_reassembled_data
                        else:
                            http_raw_payload = tcp_layer.payload
                        http_raw_payload = binascii.unhexlify(http_raw_payload.replace(':', ''))
                        # use dpkt.http.Request for parsing HTTP payload rather than pyshark
                        # since it gives a better low level access such as HTTP headers ordering
                        http_req = FormbookHTTPRequest(http_raw_payload,  int(pkt.number))
                        return http_req.formbook_decode_request()
                    elif l.get_field('response'):
                        pass  # Not implemented yet
            layer_index += 1

    def analyze_pcap(self):
        for pkt in self.cap:
            fb_req = self.extract_http_request(pkt)
            if fb_req:
                print(fb_req)


if __name__ == '__main__':
    global args
    parser = argparse.ArgumentParser(description='Parse and decode a PCAP containing formbook communications.')
    parser.add_argument('--dump-directory', default='dump', help='path to the directory containing extracted screenshots')
    parser.add_argument('pcap', help='path to the input PCAP file')
    args = parser.parse_args()

    logging.basicConfig(format="%(levelname)s:pkt %(pkt)d:%(message)s")

    fb_pcap = FormbookPcapAnalyzer(args)
    fb_pcap.analyze_pcap()
