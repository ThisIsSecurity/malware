
#define UNLOADED_FILE   1
#include <idc.idc>

static main(void)
{
  Enums();              // enumerations
  Structures();         // structure types
  ApplyStrucTInfos();
	set_inf_attr(INF_LOW_OFF, 0x401000);
	set_inf_attr(INF_HIGH_OFF, 0x509800);
}

static Enums_0(id) {

	id = add_enum(-1,"__TI_flags",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"TI_IsConst",	0X1,	0x1);
	add_enum_member(id,"TI_IsVolatile",	0X2,	0x2);
	add_enum_member(id,"TI_IsUnaligned",	0X4,	0x4);
	add_enum_member(id,"TI_IsPure",	0X8,	0x8);
	add_enum_member(id,"TI_IsWinRT",	0X10,	0x10);
	id = add_enum(-1,"__CT_flags",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"CT_IsSimpleType",	0X1,	0x1);
	add_enum_member(id,"CT_ByReferenceOnly",	0X2,	0x2);
	edd_enum_member(id,"CT_HasVirtualBase",	0X4,	0x4);
	add_enum_member(id,"CT_IsWinRTHandle",	0X8,	0x8);
	add_enum_member(id,"CT_IsStdBadAlloc",	0X10,	0x10);
	id = add_enum(-1,"GET_FILEEX_INFO_LEVELS",0x1100000);
	add_enum_member(id,"GetFileExInfoStandard",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,0,-1),"The lpFileInformation parameter is a\nWIN32_FILE_ATTRIBUTE_DATA structure.",0);
	add_enum_member(id,"GetFileExMaxInfoLevel",	0X1,	-1);
	id = add_enum(-1,"FINDEX_INFO_LEVELS",0x1100000);
	add_enum_member(id,"FindExInfoStandard",	0,	-1);
	add_enum_member(id,"FindExInfoMaxInfoLevel",	0X1,	-1);
	id = add_enum(-1,"FINDEX_SEARCH_OPS",0x1100000);
	add_enum_member(id,"FindExSearchNameMatch",	0,	-1);
	add_enum_member(id,"FindExSearchLimitToDirectories",	0X1,	-1);
	add_enum_member(id,"FindExSearchLimitToDevices",	0X2,	-1);
	add_enum_member(id,"FindExSearchMaxSearchOp",	0X3,	-1);
	id = add_enum(-1,"MACRO_CSIDL",0x1100000);
	add_enum_member(id,"CSIDL_DESKTOP",	0,	-1);
	add_enum_member(id,"CSIDL_INTERNET",	0X1,	-1);
	add_enum_member(id,"CSIDL_PROGRAMS",	0X2,	-1);
	add_enum_member(id,"CSIDL_CONTROLS",	0X3,	-1);
	add_enum_member(id,"CSIDL_PRINTERS",	0X4,	-1);
	add_enum_member(id,"CSIDL_PERSONAL",	0X5,	-1);
	add_enum_member(id,"CSIDL_MYDOCUMENTS",	0X5,	-1);
	add_enum_member(id,"CSIDL_FAVORITES",	0X6,	-1);
	add_enum_member(id,"CSIDL_STARTUP",	0X7,	-1);
	add_enum_member(id,"CSIDL_RECENT",	0X8,	-1);
	add_enum_member(id,"CSIDL_SENDTO",	0X9,	-1);
	add_enum_member(id,"CSIDL_BITBUCKET",	0XA,	-1);
	add_enum_member(id,"CSIDL_STARTMENU",	0XB,	-1);
	add_enum_member(id,"CSIDL_MYMUSIC",	0XD,	-1);
	add_enum_member(id,"CSIDL_MYVIDEO",	0XE,	-1);
	add_enum_member(id,"CSIDL_DESKTOPDIRECTORY",	0X10,	-1);
	add_enum_member(id,"CSIDL_DRIVES",	0X11,	-1);
	add_enum_member(id,"CSIDL_NETWORK",	0X12,	-1);
	add_enum_member(id,"CSIDL_NETHOOD",	0X13,	-1);
	add_enum_member(id,"CSIDL_FONTS",	0X14,	-1);
	add_enum_member(id,"CSIDL_TEMPLATES",	0X15,	-1);
	add_enum_member(id,"CSIDL_COMMON_STARTMENU",	0X16,	-1);
	add_enum_member(id,"CSIDL_COMMON_PROGRAMS",	0X17,	-1);
	add_enum_member(id,"CSIDL_COMMON_STARTUP",	0X18,	-1);
	add_enum_member(id,"CSIDL_COMMON_DESKTOPDIRECTORY",	0X19,	-1);
	add_enum_member(id,"CSIDL_APPDATA",	0X1A,	-1);
	add_enum_member(id,"CSIDL_PRINTHOOD",	0X1B,	-1);
	add_enum_member(id,"CSIDL_LOCAL_APPDATA",	0X1C,	-1);
	add_enum_member(id,"CSIDL_ALTSTARTUP",	0X1D,	-1);
	add_enum_member(id,"CSIDL_COMMON_ALTSTARTUP",	0X1E,	-1);
	add_enum_member(id,"CSIDL_COMMON_FAVORITES",	0X1F,	-1);
	add_enum_member(id,"CSIDL_INTERNET_CACHE",	0X20,	-1);
	add_enum_member(id,"CSIDL_COOKIES",	0X21,	-1);
	add_enum_member(id,"CSIDL_HISTORY",	0X22,	-1);
	add_enum_member(id,"CSIDL_COMMON_APPDATA",	0X23,	-1);
	add_enum_member(id,"CSIDL_WINDOWS",	0X24,	-1);
	add_enum_member(id,"CSIDL_SYSTEM",	0X25,	-1);
	add_enum_member(id,"CSIDL_PROGRAM_FILES",	0X26,	-1);
	add_enum_member(id,"CSIDL_MYPICTURES",	0X27,	-1);
	add_enum_member(id,"CSIDL_PROFILE",	0X28,	-1);
	add_enum_member(id,"CSIDL_SYSTEMX86",	0X29,	-1);
	add_enum_member(id,"CSIDL_PROGRAM_FILESX86",	0X2A,	-1);
	add_enum_member(id,"CSIDL_PROGRAM_FILES_COMMON",	0X2B,	-1);
	add_enum_member(id,"CSIDL_PROGRAM_FILES_COMMONX86",	0X2C,	-1);
	add_enum_member(id,"CSIDL_COMMON_TEMPLATES",	0X2D,	-1);
	add_enum_member(id,"CSIDL_COMMON_DOCUMENTS",	0X2E,	-1);
	add_enum_member(id,"CSIDL_COMMON_ADMINTOOLS",	0X2F,	-1);
	add_enum_member(id,"CSIDL_ADMINTOOLS",	0X30,	-1);
	add_enum_member(id,"CSIDL_CONNECTIONS",	0X31,	-1);
	add_enum_member(id,"CSIDL_COMMON_MUSIC",	0X35,	-1);
	add_enum_member(id,"CSIDL_COMMON_PICTURES",	0X36,	-1);
	add_enum_member(id,"CSIDL_COMMON_VIDEO",	0X37,	-1);
	add_enum_member(id,"CSIDL_RESOURCES",	0X38,	-1);
	add_enum_member(id,"CSIDL_RESOURCES_LOCALIZED",	0X39,	-1);
	add_enum_member(id,"CSIDL_COMMON_OEM_LINKS",	0X3A,	-1);
	add_enum_member(id,"CSIDL_CDBURN_AREA",	0X3B,	-1);
	add_enum_member(id,"CSIDL_COMPUTERSNEARME",	0X3D,	-1);
	add_enum_member(id,"CSIDL_FLAG_PER_USER_INIT",	0X800,	-1);
	add_enum_member(id,"CSIDL_FLAG_NO_ALIAS",	0X1000,	-1);
	add_enum_member(id,"CSIDL_FLAG_DONT_UNEXPAND",	0X2000,	-1);
	add_enum_member(id,"CSIDL_FLAG_DONT_VERIFY",	0X4000,	-1);
	add_enum_member(id,"CSIDL_FLAG_CREATE",	0X8000,	-1);
	add_enum_member(id,"CSIDL_FLAG_MASK",	0XFF00,	-1);
	id = add_enum(-1,"MACRO_KEY",0x1100000);
	add_enum_member(id,"KEY_QUERY_VALUE",	0X1,	-1);
	add_enum_member(id,"KEY_SET_VALUE",	0X2,	-1);
	add_enum_member(id,"KEY_CREATE_SUB_KEY",	0X4,	-1);
	add_enum_member(id,"KEY_ENUMERATE_SUB_KEYS",	0X8,	-1);
	add_enum_member(id,"KEY_NOTIFY",	0X10,	-1);
	add_enum_member(id,"KEY_CREATE_LINK",	0X20,	-1);
	add_enum_member(id,"KEY_WOW64_64KEY",	0X100,	-1);
	add_enum_member(id,"KEY_WOW64_32KEY",	0X200,	-1);
	add_enum_member(id,"KEY_WOW64_RES",	0X300,	-1);
	add_enum_member(id,"KEY_WRITE",	0X20006,	-1);
	add_enum_member(id,"KEY_READ",	0X20019,	-1);
	add_enum_member(id,"KEY_EXECUTE",	0X20019,	-1);
	add_enum_member(id,"KEY_ALL_ACCESS",	0XF003F,	-1);
	id = add_enum(-1,"MACRO_RRF",0x1100000);
	add_enum_member(id,"RRF_RT_REG_NONE",	0X1,	-1);
	add_enum_member(id,"RRF_RT_REG_SZ",	0X2,	-1);
	add_enum_member(id,"RRF_RT_REG_EXPAND_SZ",	0X4,	-1);
	add_enum_member(id,"RRF_RT_REG_BINARY",	0X8,	-1);
	add_enum_member(id,"RRF_RT_REG_DWORD",	0X10,	-1);
	add_enum_member(id,"RRF_RT_DWORD",	0X18,	-1);
	add_enum_member(id,"RRF_RT_REG_MULTI_SZ",	0X20,	-1);
	add_enum_member(id,"RRF_RT_REG_QWORD",	0X40,	-1);
	add_enum_member(id,"RRF_RT_QWORD",	0X48,	-1);
	add_enum_member(id,"RRF_RT_ANY",	0XFFFF,	-1);
	add_enum_member(id,"RRF_NOEXPAND",	0X10000000,	-1);
	add_enum_member(id,"RRF_ZEROONFAILURE",	0X20000000,	-1);
	id = add_enum(-1,"MACRO_HKEY",0x1100000);
	add_enum_member(id,"HKEY_CLASSES_ROOT",	0X80000000,	-1);
	add_enum_member(id,"HKEY_CURRENT_USER",	0X80000001,	-1);
	add_enum_member(id,"HKEY_LOCAL_MACHINE",	0X80000002,	-1);
	add_enum_member(id,"HKEY_USERS",	0X80000003,	-1);
	add_enum_member(id,"HKEY_PERFORMANCE_DATA",	0X80000004,	-1);
	add_enum_member(id,"HKEY_CURRENT_CONFIG",	0X80000005,	-1);
	add_enum_member(id,"HKEY_DYN_DATA",	0X80000006,	-1);
	add_enum_member(id,"HKEY_CURRENT_USER_LOCAL_SETTINGS",	0X80000007,	-1);
	add_enum_member(id,"HKEY_PERFORMANCE_TEXT",	0X80000050,	-1);
	add_enum_member(id,"HKEY_PERFORMANCE_NLSTEXT",	0X80000060,	-1);
	id = add_enum(-1,"MACRO_CRYPT_Y",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"CRYPT_Y_ONLY",	0X1,	0x1);
	add_enum_member(id,"CRYPT_LITTLE_ENDIAN",	0X1,	0x1);
	add_enum_member(id,"CRYPT_MACHINE_DEFAULT",	0X1,	0x1);
	add_enum_member(id,"CRYPT_SSL2_SLUMMING",	0X2,	0x2);
	add_enum_member(id,"CRYPT_USER_DEFAULT",	0X2,	0x2);
	add_enum_member(id,"CRYPT_DELETE_DEFAULT",	0X4,	0x4);
	id = add_enum(-1,"MACRO_HEAP",0x1100000);
	add_enum_member(id,"HEAP_NO_SERIALIZE",	0X1,	-1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,-1),"Serialized access is not used when the\nheap functions access this heap. This\noption applies to all subsequent heap\nfunction calls. Alternatively, you can\nspecify this option on individual heap\nfunction calls. This option cannot be\nused with the low-fragmentation heap\n(LFH).For more information about\nserialized access, see the Remarks\nsection of this topic.",0);
	add_enum_member(id,"HEAP_GROWABLE",	0X2,	-1);
	add_enum_member(id,"HEAP_GENERATE_EXCEPTIONS",	0X4,	-1);
	set_enum_member_cmt(get_enum_member(id,0X4,0,-1),"The system raises an exception to\nindicate failure (for example, an out-\nof-memory condition) for calls to\nHeapAlloc and HeapReAlloc instead of\nreturning NULL.",0);
	add_enum_member(id,"HEAP_ZERO_MEMORY",	0X8,	-1);
	set_enum_member_cmt(get_enum_member(id,0X8,0,-1),"The allocated memory will be initialized\nto zero. Otherwise, the memory is not\ninitialized to zero.",0);
	add_enum_member(id,"HEAP_REALLOC_IN_PLACE_ONLY",	0X10,	-1);
	set_enum_member_cmt(get_enum_member(id,0X10,0,-1),"There can be no movement when\nreallocating a memory block. If this\nvalue is not specified, the function may\nmove the block to a new location. If\nthis value is specified and the block\ncannot be resized without moving, the\nfunction fails, leaving the original\nmemory block unchanged.",0);
	add_enum_member(id,"HEAP_TAG_SHIFT",	0X12,	-1);
	add_enum_member(id,"HEAP_TAIL_CHECKING_ENABLED",	0X20,	-1);
	add_enum_member(id,"HEAP_FREE_CHECKING_ENABLED",	0X40,	-1);
	add_enum_member(id,"HEAP_DISABLE_COALESCE_ON_FREE",	0X80,	-1);
	add_enum_member(id,"HEAP_MAXIMUM_TAG",	0XFFF,	-1);
	add_enum_member(id,"HEAP_PSEUDO_TAG_FLAG",	0X8000,	-1);
	add_enum_member(id,"HEAP_CREATE_ALIGN_16",	0X10000,	-1);
	add_enum_member(id,"HEAP_CREATE_ENABLE_TRACING",	0X20000,	-1);
	id = add_enum(-1,"MACRO_ENABLE",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"ENABLE_PROCESSED_INPUT",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"CTRL+C is processed by the system and is\nnot placed in the input buffer. If the\ninput buffer is being read by ReadFile\nor ReadConsole, other control keys are\nprocessed by the system and are not\nreturned in the ReadFile or ReadConsole\nbuffer. If the ENABLE_LINE_INPUT mode is\nalso enabled, backspace, carriage\nreturn, and linefeed characters are\nhandled by the system.",0);
	add_enum_member(id,"ENABLE_PROCESSED_OUTPUT",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,1,0x1),"Characters written by the WriteFile or\nWriteConsole function or echoed by the\nReadFile or ReadConsole function are\nparsed for ASCII control sequences, and\nthe correct action is performed.\nBackspace, tab, bell, carriage return,\nand linefeed characters are processed.",0);
	add_enum_member(id,"ENABLE_LINE_INPUT",	0X2,	0x2);
	set_enum_member_cmt(get_enum_member(id,0X2,0,0x2),"The ReadFile or ReadConsole function\nreturns only when a carriage return\ncharacter is read. If this mode is\ndisabled, the functions return when one\nor more characters are available.",0);
	add_enum_member(id,"ENABLE_WRAP_AT_EOL_OUTPUT",	0X2,	0x2);
	set_enum_member_cmt(get_enum_member(id,0X2,1,0x2),"When writing with WriteFile or\nWriteConsole or echoing with ReadFile or\nReadConsole, the cursor moves to the\nbeginning of the next row when it\nreaches the end of the current row. This\ncauses the rows displayed in the console\nwindow to scroll up automatically when\nthe cursor advances beyond the last row\nin the window. It also causes the\ncontents of the console screen buffer to\nscroll up (discarding the top row of the\nconsole screen buffer) when the cursor\nadvances beyond the last row in the\nconsole screen buffer. If this mode is\ndisabled, the last character in the row\nis overwritten with any subsequent\ncharacters.",0);
	add_enum_member(id,"ENABLE_ECHO_INPUT",	0X4,	0x4);
	set_enum_member_cmt(get_enum_member(id,0X4,0,0x4),"Characters read by the ReadFile or\nReadConsole function are written to the\nactive screen buffer as they are read.\nThis mode can be used only if the\nENABLE_LINE_INPUT mode is also enabled.",0);
	add_enum_member(id,"ENABLE_WINDOW_INPUT",	0X8,	0x8);
	set_enum_member_cmt(get_enum_member(id,0X8,0,0x8),"User interactions that change the size\nof the console screen buffer are\nreported in the console's input buffer.\nInformation about these events can be\nread from the input buffer by\napplications using the ReadConsoleInput\nfunction, but not by those using\nReadFile or ReadConsole.",0);
	add_enum_member(id,"ENABLE_MOUSE_INPUT",	0X10,	0x10);
	set_enum_member_cmt(get_enum_member(id,0X10,0,0x10),"If the mouse pointer is within the\nborders of the console window and the\nwindow has the keyboard focus, mouse\nevents generated by mouse movement and\nbutton presses are placed in the input\nbuffer. These events are discarded by\nReadFile or ReadConsole, even when this\nmode is enabled.",0);
	id = add_enum(-1,"MACRO_CP_ACP",0x2220000);
	add_enum_member(id,"CP_ACP",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,0,-1),"The system default Windows ANSI code\npage. Note This value can be different\non different computers, even on the same\nnetwork. It can be changed on the same\ncomputer, leading to stored data\nbecoming irrecoverably corrupted. This\nvalue is only intended for temporary use\nand permanent storage should use UTF-16\nor UTF-8 if possible.",0);
	add_enum_member(id,"CP_OEMCP",	0X1,	-1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,-1),"The current system OEM code page. Note\nThis value can be different on different\ncomputers, even on the same network. It\ncan be changed on the same computer,\nleading to stored data becoming\nirrecoverably corrupted. This value is\nonly intended for temporary use and\npermanent storage should use UTF-16 or\nUTF-8 if possible.",0);
	add_enum_member(id,"CP_MACCP",	0X2,	-1);
	set_enum_member_cmt(get_enum_member(id,0X2,0,-1),"The current system Macintosh code page.\nNote This value can be different on\ndifferent computers, even on the same\nnetwork. It can be changed on the same\ncomputer, leading to stored data\nbecoming irrecoverably corrupted. This\nvalue is only intended for temporary use\nand permanent storage should use UTF-16\nor UTF-8 if possible.Note This value is\nused primarily in legacy code and should\nnot generally be needed since modern\nMacintosh computers use Unicode for\nencoding.",0);
	add_enum_member(id,"CP_THREAD_ACP",	0X3,	-1);
	set_enum_member_cmt(get_enum_member(id,0X3,0,-1),"Windows 2000: The Windows ANSI code page\nfor the current thread. Note This value\ncan be different on different computers,\neven on the same network. It can be\nchanged on the same computer, leading to\nstored data becoming irrecoverably\ncorrupted. This value is only intended\nfor temporary use and permanent storage\nshould use UTF-16 or UTF-8 if possible.",0);
	add_enum_member(id,"CP_SYMBOL",	0X2A,	-1);
	set_enum_member_cmt(get_enum_member(id,0X2A,0,-1),"Windows 2000: Symbol code page (42).",0);
	add_enum_member(id,"CP_UTF7",	0XFDE8,	-1);
	set_enum_member_cmt(get_enum_member(id,0XFDE8,0,-1)," UTF-7. Use this value only when forced\nby a 7-bit transport mechanism. Use of\nUTF-8 is preferred. With this value set,\nlpDefaultChar and lpUsedDefaultChar must\nbe set to NULL.",0);
	add_enum_member(id,"CP_UTF8",	0XFDE9,	-1);
	set_enum_member_cmt(get_enum_member(id,0XFDE9,0,-1),"UTF-8. With this value set,\nlpDefaultChar and lpUsedDefaultChar must\nbe set to NULL.",0);
	id = add_enum(-1,"MACRO_FORMAT",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"FORMAT_MESSAGE_MAX_WIDTH_MASK",	0XFF,	0xFF);
	set_enum_member_cmt(get_enum_member(id,0XFF,0,0xFF),"The function ignores regular line breaks\nin the message definition text. The\nfunction stores hard-coded line breaks\nin the message definition text into the\noutput buffer. The function generates no\nnew line breaks.",0);
	add_enum_member(id,"FORMAT_MESSAGE_ALLOCATE_BUFFER",	0X100,	0x100);
	set_enum_member_cmt(get_enum_member(id,0X100,0,0x100),"The function allocates a buffer large\nenough to hold the formatted message,\nand places a pointer to the allocated\nbuffer at the address specified by\nlpBuffer. The lpBuffer parameter is a\npointer to an LPTSTR; you must cast the\npointer to an LPTSTR (for example,\n(LPTSTR)&lpBuffer). The nSize parameter\nspecifies the minimum number of TCHARs\nto allocate for an output message\nbuffer. The caller should use the\nLocalFree function to free the buffer\nwhen it is no longer needed.",0);
	add_enum_member(id,"FORMAT_MESSAGE_IGNORE_INSERTS",	0X200,	0x200);
	set_enum_member_cmt(get_enum_member(id,0X200,0,0x200),"Insert sequences in the message\ndefinition are to be ignored and passed\nthrough to the output buffer unchanged.\nThis flag is useful for fetching a\nmessage for later formatting. If this\nflag is set, the Arguments parameter is\nignored.",0);
	add_enum_member(id,"FORMAT_MESSAGE_FROM_STRING",	0X400,	0x400);
	set_enum_member_cmt(get_enum_member(id,0X400,0,0x400),"Pointer to a string that consists of\nunformatted message text. It will be\nscanned for inserts and formatted\naccordingly.",0);
	add_enum_member(id,"FORMAT_MESSAGE_FROM_HMODULE",	0X800,	0x800);
	set_enum_member_cmt(get_enum_member(id,0X800,0,0x800),"A handle to the module that contains the\nmessage table to search.",0);
	add_enum_member(id,"FORMAT_MESSAGE_FROM_SYSTEM",	0X1000,	0x1000);
	set_enum_member_cmt(get_enum_member(id,0X1000,0,0x1000),"The function should search the system\nmessage-table resource(s) for the\nrequested message. If this flag is\nspecified with\nFORMAT_MESSAGE_FROM_HMODULE, the\nfunction searches the system message\ntable if the message is not found in the\nmodule specified by lpSource. This flag\ncannot be used with\nFORMAT_MESSAGE_FROM_STRING. If this flag\nis specified, an application can pass\nthe result of the GetLastError function\nto retrieve the message text for a\nsystem-defined error.",0);
	add_enum_member(id,"FORMAT_MESSAGE_ARGUMENT_ARRAY",	0X2000,	0x2000);
	set_enum_member_cmt(get_enum_member(id,0X2000,0,0x2000),"The Arguments parameter is not a va_list\nstructure, but is a pointer to an array\nof values that represent the\narguments.This flag cannot be used with\n64-bit integer values. If you are using\na 64-bit integer, you must use the\nva_list structure.",0);
	id = add_enum(-1,"Browserchoice",0x1100000);
	add_enum_member(id,"Amigo",	0X1,	-1);
	add_enum_member(id,"Chrome",	0X2,	-1);
	add_enum_member(id,"Vivaldi",	0X3,	-1);
	add_enum_member(id,"Yandex",	0X4,	-1);
	add_enum_member(id,"Kometa",	0X5,	-1);
	add_enum_member(id,"Orbitum",	0X6,	-1);
	add_enum_member(id,"Comodo",	0X7,	-1);
	add_enum_member(id,"Torch",	0X8,	-1);
	add_enum_member(id,"Opera",	0X9,	-1);
	add_enum_member(id,"Xpom",	0XA,	-1);
	add_enum_member(id,"Nichrome",	0XB,	-1);
	add_enum_member(id,"Chromium",	0XC,	-1);
	add_enum_member(id,"Maxthon5",	0XD,	-1);
	add_enum_member(id,"Sputnik",	0XE,	-1);
	add_enum_member(id,"Epic_Privacy_browser",	0XF,	-1);
	add_enum_member(id,"CoccocBrowser",	0X10,	-1);
	id = add_enum(-1,"CURLOPT",0x1100000);
	add_enum_member(id,"CURLOPT_WRITEDATA",	0X2711,	-1);
	add_enum_member(id,"CURLOPT_URL",	0X2712,	-1);
	add_enum_member(id,"CURLOPT_HTTPPOST",	0X2728,	-1);
	add_enum_member(id,"CURLOPT_WRITEFUNCTION",	0X4E2B,	-1);
	id = add_enum(-1,"CURLFORM",0x1100000);
	add_enum_member(id,"CURLFORM_COPYNAME",	0X1,	-1);
	add_enum_member(id,"CURLFORM_COPYCONTENTS",	0X4,	-1);
	add_enum_member(id,"CURLFORM_FILE",	0XA,	-1);
	add_enum_member(id,"CURLFORM_END",	0X11,	-1);
	id = add_enum(-1,"Null_Enum",0x1100000);
	add_enum_member(id,"NULL_dwFlags_FormatMessageW",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,0,-1),"There are no output line width\nrestrictions. The function stores line\nbreaks that are in the message\ndefinition text into the output buffer.",0);
	add_enum_member(id,"NULL_dwFlags_FormatMessageA",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,1,-1),"There are no output line width\nrestrictions. The function stores line\nbreaks that are in the message\ndefinition text into the output buffer.",0);
	add_enum_member(id,"NULL_dwCreationFlags_CreateThread",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,2,-1),"The thread runs immediately after\ncreation.",0);
	add_enum_member(id,"NULL_dwFlags_GetModuleHandleExW",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,3,-1),"Increment the reference count. This is\nthe default case. The caller must use\nthe FreeLibrary function when they have\nfinished using the module handle.",0);
	add_enum_member(id,"NULL_dwShareMode_CreateFileW",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,4,-1),"Prevents other processes from opening a\nfile or device if they request delete,\nread, or write access.",0);
	add_enum_member(id,"NULL_dwShareMode_CreateFileA",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,5,-1),"Prevents other processes from opening a\nfile or device if they request delete,\nread, or write access.",0);
	id = add_enum(-1,"MACRO_DONT",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"DONT_RESOLVE_DLL_REFERENCES",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1)," If this value is used, and the\nexecutable module is a DLL, the system\ndoes not call DllMain for process and\nthread initialization and termination.\nAlso, the system does not load\nadditional executable modules that are\nreferenced by the specified module. Note\nUse extreme care when using this value.\nIf LoadLibrary or LoadLibraryEx is\ncalled for the same DLL after the DLL is\nloaded, then the DLL references will not\nhave been resolved. This is because the\nsecond call to LoadLibrary or\nLoadLibraryEx simply returns a handle to\nthe already loaded DLL. In this case,\nthe process is likely to terminate\nabnormally.If you are planning only to\naccess data or resources in the DLL, it\nis better to use\nLOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE or\nLOAD_LIBRARY_AS_IMAGE_RESOURCE or both.",0);
	id = add_enum(-1,"MACRO_MB_PRECOMPOSED",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"MB_PRECOMPOSED",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"Default; do not use with MB_COMPOSITE.\nAlways use precomposed characters, that\nis, characters having a single character\nvalue for a base or nonspacing character\ncombination. For example, in the\ncharacter è, the e is the base character\nand the accent grave mark is the\nnonspacing character. If a single\nUnicode code point is defined for a\ncharacter, the application should use it\ninstead of a separate base character and\na nonspacing character. For example, Ä\nis represented by the single Unicode\ncode point LATIN CAPITAL LETTER A WITH\nDIAERESIS (U+00C4).",0);
	add_enum_member(id,"MB_COMPOSITE",	0X2,	0x2);
	set_enum_member_cmt(get_enum_member(id,0X2,0,0x2),"Always use decomposed characters, that\nis, characters in which a base character\nand one or more nonspacing characters\neach have distinct code point values.\nFor example, Ä is represented by A + ¨:\nLATIN CAPITAL LETTER A (U+0041) +\nCOMBINING DIAERESIS (U+0308). Note that\nthis flag cannot be used with\nMB_PRECOMPOSED.",0);
	add_enum_member(id,"MB_USEGLYPHCHARS",	0X4,	0x4);
	set_enum_member_cmt(get_enum_member(id,0X4,0,0x4),"Use glyph characters instead of control\ncharacters.",0);
	add_enum_member(id,"MB_ERR_INVALID_CHARS",	0X8,	0x8);
	set_enum_member_cmt(get_enum_member(id,0X8,0,0x8)," Starting with Windows Vista, the\nfunction does not drop illegal code\npoints if the application does not set\nthis flag.Windows 2000 with SP4 and\nlater, Windows XP: Fail if an invalid\ninput character is encountered. If this\nflag is not set, the function silently\ndrops illegal code points. A call to\nGetLastError returns\nERROR_NO_UNICODE_TRANSLATION.",0);
	id = add_enum(-1,"MACRO_FILE_BEGIN",0x2220000);
	add_enum_member(id,"FILE_BEGIN",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,0,-1),"The starting point is zero (0) or the\nbeginning of the file.",0);
	add_enum_member(id,"FILE_CURRENT",	0X1,	-1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,-1),"The starting point is the current value\nof the file pointer.",0);
	add_enum_member(id,"FILE_END",	0X2,	-1);
	set_enum_member_cmt(get_enum_member(id,0X2,0,-1),"The starting point is the current end-\nof-file position.",0);
	id = add_enum(-1,"MACRO_LOCKFILE",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"LOCKFILE_FAIL_IMMEDIATELY",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"The function returns immediately if it\nis unable to acquire the requested lock.\nOtherwise, it waits.",0);
	add_enum_member(id,"LOCKFILE_EXCLUSIVE_LOCK",	0X2,	0x2);
	set_enum_member_cmt(get_enum_member(id,0X2,0,0x2),"The function requests an exclusive lock.\nOtherwise, it requests a shared lock.",0);
	id = add_enum(-1,"MACRO_DEBUG",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"DEBUG_PROCESS",	0X1,	0x1);
	add_enum_member(id,"DEBUG_ONLY_THIS_PROCESS",	0X2,	0x2);
	id = add_enum(-1,"MACRO_EXCEPTION",0x2220000);
	add_enum_member(id,"EXCEPTION_CONTINUE_SEARCH",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,0,-1),"Proceed with normal execution of\nUnhandledExceptionFilter. That means\nobeying the SetErrorMode flags, or\ninvoking the Application Error pop-up\nmessage box.",0);
	add_enum_member(id,"EXCEPTION_EXECUTE_HANDLER",	0X1,	-1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,-1),"Return from UnhandledExceptionFilter and\nexecute the associated exception\nhandler. This usually results in process\ntermination.",0);
	add_enum_member(id,"EXCEPTION_CONTINUE_EXECUTION",	0XFFFFFFFF,	-1);
	set_enum_member_cmt(get_enum_member(id,0XFFFFFFFF,0,-1),"Return from UnhandledExceptionFilter and\ncontinue execution from the point of the\nexception. Note that the filter function\nis free to modify the continuation state\nby modifying the exception information\nsupplied through its\nLPEXCEPTION_POINTERS parameter.",0);
	id = add_enum(-1,"MACRO_PF",0x2220000);
	add_enum_member(id,"PF_FLOATING_POINT_PRECISION_ERRATA",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,0,-1),"On a Pentium, a floating-point precision\nerror can occur in rare circumstances.",0);
	add_enum_member(id,"PF_FLOATING_POINT_EMULATED",	0X1,	-1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,-1),"Floating-point operations are emulated\nusing a software emulator.This function\nreturns a nonzero value if floating-\npoint operations are emulated;\notherwise, it returns zero.",0);
	add_enum_member(id,"PF_COMPARE_EXCHANGE_DOUBLE",	0X2,	-1);
	set_enum_member_cmt(get_enum_member(id,0X2,0,-1),"The atomic compare and exchange\noperation (cmpxchg) is available.",0);
	add_enum_member(id,"PF_MMX_INSTRUCTIONS_AVAILABLE",	0X3,	-1);
	set_enum_member_cmt(get_enum_member(id,0X3,0,-1),"The MMX instruction set is available.",0);
	add_enum_member(id,"PF_PPC_MOVEMEM_64BIT_OK",	0X4,	-1);
	add_enum_member(id,"PF_ALPHA_BYTE_INSTRUCTIONS",	0X5,	-1);
	add_enum_member(id,"PF_XMMI_INSTRUCTIONS_AVAILABLE",	0X6,	-1);
	set_enum_member_cmt(get_enum_member(id,0X6,0,-1),"The SSE instruction set is available.",0);
	add_enum_member(id,"PF_AMD3D_INSTRUCTIONS_AVAILABLE",	0X7,	-1);
	id = add_enum(-1,"MACRO_AF",0x2220000);
	add_enum_member(id,"AF_UNSPEC",	0,	-1);
	set_enum_member_cmt(get_enum_member(id,0,0,-1),"The address family is unspecified.",0);
	add_enum_member(id,"AF_UNIX",	0X1,	-1);
	add_enum_member(id,"AF_INET",	0X2,	-1);
	set_enum_member_cmt(get_enum_member(id,0X2,0,-1),"The Internet Protocol version 4 (IPv4)\naddress family.",0);
	add_enum_member(id,"AF_IMPLINK",	0X3,	-1);
	add_enum_member(id,"AF_PUP",	0X4,	-1);
	add_enum_member(id,"AF_CHAOS",	0X5,	-1);
	add_enum_member(id,"AF_NS",	0X6,	-1);
	add_enum_member(id,"AF_IPX",	0X6,	-1);
	set_enum_member_cmt(get_enum_member(id,0X6,1,-1),"The IPX/SPX address family. This address\nfamily is only supported if the NWLink\nIPX/SPX NetBIOS Compatible Transport\nprotocol is installed. This address\nfamily is not supported on Windows Vista\nand later.",0);
	add_enum_member(id,"AF_ISO",	0X7,	-1);
	add_enum_member(id,"AF_OSI",	0X7,	-1);
	add_enum_member(id,"AF_ECMA",	0X8,	-1);
	add_enum_member(id,"AF_DATAKIT",	0X9,	-1);
	add_enum_member(id,"AF_CCITT",	0XA,	-1);
	add_enum_member(id,"AF_SNA",	0XB,	-1);
	add_enum_member(id,"AF_DECnet",	0XC,	-1);
	add_enum_member(id,"AF_DLI",	0XD,	-1);
	add_enum_member(id,"AF_LAT",	0XE,	-1);
	add_enum_member(id,"AF_HYLINK",	0XF,	-1);
	add_enum_member(id,"AF_APPLETALK",	0X10,	-1);
	set_enum_member_cmt(get_enum_member(id,0X10,0,-1),"The AppleTalk address family. This\naddress family is only supported if the\nAppleTalk protocol is installed. This\naddress family is not supported on\nWindows Vista and later.",0);
	add_enum_member(id,"AF_NETBIOS",	0X11,	-1);
	set_enum_member_cmt(get_enum_member(id,0X11,0,-1),"The NetBIOS address family. This address\nfamily is only supported if a Windows\nSockets provider for NetBIOS is\ninstalled.",0);
	add_enum_member(id,"AF_VOICEVIEW",	0X12,	-1);
	add_enum_member(id,"AF_FIREFOX",	0X13,	-1);
	add_enum_member(id,"AF_UNKNOWN1",	0X14,	-1);
	add_enum_member(id,"AF_BAN",	0X15,	-1);
	add_enum_member(id,"AF_ATM",	0X16,	-1);
	add_enum_member(id,"AF_INET6",	0X17,	-1);
	set_enum_member_cmt(get_enum_member(id,0X17,0,-1),"The Internet Protocol version 6 (IPv6)\naddress family.",0);
	add_enum_member(id,"AF_CLUSTER",	0X18,	-1);
	add_enum_member(id,"AF_12844",	0X19,	-1);
	add_enum_member(id,"AF_MAX",	0X1A,	-1);
	id = add_enum(-1,"MACRO_SOCK",0x2220000);
	add_enum_member(id,"SOCK_STREAM",	0X1,	-1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,-1),"A socket type that provides sequenced,\nreliable, two-way, connection-based byte\nstreams with an OOB data transmission\nmechanism. This socket type uses the\nTransmission Control Protocol (TCP) for\nthe Internet address family (AF_INET or\nAF_INET6).",0);
	add_enum_member(id,"SOCK_DGRAM",	0X2,	-1);
	set_enum_member_cmt(get_enum_member(id,0X2,0,-1),"A socket type that supports datagrams,\nwhich are connectionless, unreliable\nbuffers of a fixed (typically small)\nmaximum length. This socket type uses\nthe User Datagram Protocol (UDP) for the\nInternet address family (AF_INET or\nAF_INET6).",0);
	add_enum_member(id,"SOCK_RAW",	0X3,	-1);
	set_enum_member_cmt(get_enum_member(id,0X3,0,-1),"A socket type that provides a raw socket\nthat allows an application to manipulate\nthe next upper-layer protocol header. To\nmanipulate the IPv4 header, the\nIP_HDRINCL socket option must be set on\nthe socket. To manipulate the IPv6\nheader, the IPV6_HDRINCL socket option\nmust be set on the socket.",0);
	add_enum_member(id,"SOCK_RDM",	0X4,	-1);
	set_enum_member_cmt(get_enum_member(id,0X4,0,-1),"A socket type that provides a reliable\nmessage datagram. An example of this\ntype is the Pragmatic General Multicast\n(PGM) multicast protocol implementation\nin Windows, often referred to as\nreliable multicast programming. This\ntype is only supported if the Reliable\nMulticast Protocol is installed.",0);
	add_enum_member(id,"SOCK_SEQPACKET",	0X5,	-1);
	set_enum_member_cmt(get_enum_member(id,0X5,0,-1),"A socket type that provides a pseudo-\nstream packet based on datagrams.",0);
	id = add_enum(-1,"MACRO_IPPROTO",0x2220000);
	add_enum_member(id,"IPPROTO_IP",	0,	-1);
	add_enum_member(id,"IPPROTO_ICMP",	0X1,	-1);
	add_enum_member(id,"IPPROTO_IGMP",	0X2,	-1);
	add_enum_member(id,"IPPROTO_GGP",	0X3,	-1);
	add_enum_member(id,"IPPROTO_TCP",	0X6,	-1);
	set_enum_member_cmt(get_enum_member(id,0X6,0,-1),"The Transmission Control Protocol (TCP).\nThis is a possible value when the af\nparameter is AF_INET or AF_INET6 and the\ntype parameter is SOCK_STREAM.",0);
	add_enum_member(id,"IPPROTO_PUP",	0XC,	-1);
	add_enum_member(id,"IPPROTO_UDP",	0X11,	-1);
	set_enum_member_cmt(get_enum_member(id,0X11,0,-1),"The User Datagram Protocol (UDP). This\nis a possible value when the af\nparameter is AF_INET or AF_INET6 and the\ntype parameter is SOCK_DGRAM.",0);
	add_enum_member(id,"IPPROTO_IDP",	0X16,	-1);
	add_enum_member(id,"IPPROTO_ND",	0X4D,	-1);
	add_enum_member(id,"IPPROTO_RAW",	0XFF,	-1);
	add_enum_member(id,"IPPROTO_MAX",	0X100,	-1);
	id = add_enum(-1,"MACRO_GET_MODULE",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"GET_MODULE_HANDLE_EX_FLAG_PIN",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"The module stays loaded until the\nprocess is terminated, no matter how\nmany times FreeLibrary is called. This\noption cannot be used with GET_MODULE_HA\nNDLE_EX_FLAG_UNCHANGED_REFCOUNT.",0);
	add_enum_member(id,"GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT",	0X2,	0x2);
	set_enum_member_cmt(get_enum_member(id,0X2,0,0x2),"Do not increment the reference count for\nthe module. This option is equivalent to\nthe behavior of GetModuleHandle. This\noption cannot be used with\nGET_MODULE_HANDLE_EX_FLAG_PIN.",0);
	add_enum_member(id,"GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS",	0X4,	0x4);
	set_enum_member_cmt(get_enum_member(id,0X4,0,0x4),"The lpModuleName parameter is an address\nin the module.",0);
	id = add_enum(-1,"MACRO_MSG",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"MSG_OOB",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"Sends OOB data (stream-style socket such\nas SOCK_STREAM only.",0);
	add_enum_member(id,"MSG_PEEK",	0X2,	0x2);
	add_enum_member(id,"MSG_DONTROUTE",	0X4,	0x4);
	set_enum_member_cmt(get_enum_member(id,0X4,0,0x4),"Specifies that the data should not be\nsubject to routing. A Windows Sockets\nservice provider can choose to ignore\nthis flag.",0);
	add_enum_member(id,"MSG_INTERRUPT",	0X10,	0x10);
	add_enum_member(id,"MSG_MAXIOVLEN",	0X10,	0x10);
	add_enum_member(id,"MSG_PARTIAL",	0X8000,	0x8000);
	id = add_enum(-1,"MACRO_DATE",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"DATE_SHORTDATE",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"Use the short date format. This is the\ndefault. This value cannot be used with\nDATE_LONGDATE or DATE_YEARMONTH.",0);
	add_enum_member(id,"DATE_LONGDATE",	0X2,	0x2);
	set_enum_member_cmt(get_enum_member(id,0X2,0,0x2),"Use the long date format. This value\ncannot be used with DATE_SHORTDATE or\nDATE_YEARMONTH.",0);
	add_enum_member(id,"DATE_USE_ALT_CALENDAR",	0X4,	0x4);
	set_enum_member_cmt(get_enum_member(id,0X4,0,0x4),"Use the alternate calendar, if one\nexists, to format the date string. If\nthis flag is set, the function uses the\ndefault format for that alternate\ncalendar, rather than using any user\noverrides. The user overrides will be\nused only in the event that there is no\ndefault format for the specified\nalternate calendar.",0);
	add_enum_member(id,"DATE_YEARMONTH",	0X8,	0x8);
	set_enum_member_cmt(get_enum_member(id,0X8,0,0x8),"Windows Vista: Use the year/month\nformat. This value cannot be used with\nDATE_SHORTDATE or DATE_LONGDATE.",0);
	add_enum_member(id,"DATE_LTRREADING",	0X10,	0x10);
	set_enum_member_cmt(get_enum_member(id,0X10,0,0x10)," Add marks for left-to-right reading\nlayout. This value cannot be used with\nDATE_RTLREADING.",0);
	add_enum_member(id,"DATE_RTLREADING",	0X20,	0x20);
	set_enum_member_cmt(get_enum_member(id,0X20,0,0x20)," Add marks for right-to-left reading\nlayout. This value cannot be used with\nDATE_LTRREADING",0);
	id = add_enum(-1,"MACRO_SEC",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"SEC_FILE",	0X800000,	0x800000);
	add_enum_member(id,"SEC_IMAGE",	0X1000000,	0x1000000);
	set_enum_member_cmt(get_enum_member(id,0X1000000,0,0x1000000),"Specifies that the file that the hFile\nparameter specifies is an executable\nimage file. Because the mapping\ninformation and file protection are\ntaken from the image file, no other\nattributes are valid with SEC_IMAGE.",0);
	add_enum_member(id,"SEC_VLM",	0X2000000,	0x2000000);
	add_enum_member(id,"SEC_RESERVE",	0X4000000,	0x4000000);
	set_enum_member_cmt(get_enum_member(id,0X4000000,0,0x4000000)," If the file mapping object is backed by\nthe operating system paging file (the\nhfile parameter is\nINVALID_HANDLE_VALUE), specifies that\nwhen a view of the file is mapped into a\nprocess address space, the entire range\nof pages is reserved for later use by\nthe process rather than committed.\nReserved pages can be committed in\nsubsequent calls to the VirtualAlloc\nfunction. After the pages are committed,\nthey cannot be freed or decommitted with\nthe VirtualFree function.This attribute\nhas no effect for file mapping objects\nthat are backed by executable image\nfiles or data files (the hfile parameter\nis a handle to a file).SEC_RESERVE\ncannot be combined with SEC_COMMIT.",0);
	add_enum_member(id,"SEC_COMMIT",	0X8000000,	0x8000000);
	set_enum_member_cmt(get_enum_member(id,0X8000000,0,0x8000000),"If the file mapping object is backed by\nthe operating system paging file (the\nhfile parameter is\nINVALID_HANDLE_VALUE), specifies that\nwhen a view of the file is mapped into a\nprocess address space, the entire range\nof pages is committed rather than\nreserved. The system must have enough\ncommittable pages to hold the entire\nmapping. Otherwise, CreateFileMapping\nfails.This attribute has no effect for\nfile mapping objects that are backed by\nexecutable image files or data files\n(the hfile parameter is a handle to a\nfile).SEC_COMMIT cannot be combined with\nSEC_RESERVE. If no attribute is\nspecified, SEC_COMMIT is assumed.",0);
	add_enum_member(id,"SEC_NOCACHE",	0X10000000,	0x10000000);
	set_enum_member_cmt(get_enum_member(id,0X10000000,0,0x10000000),"Sets all pages to be non-\ncachable.Applications should not use\nthis attribute except when explicitly\nrequired for a device. Using the\ninterlocked functions with memory that\nis mapped with SEC_NOCACHE can result in\nan EXCEPTION_ILLEGAL_INSTRUCTION\nexception.SEC_NOCACHE requires either\nthe SEC_RESERVE or SEC_COMMIT attribute\nto be set.",0);
	id = add_enum(-1,"MACRO_PAGE",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"PAGE_NOACCESS",	0X1,	0x1);
	add_enum_member(id,"PAGE_READONLY",	0X2,	0x2);
	set_enum_member_cmt(get_enum_member(id,0X2,0,0x2),"Allows views to be mapped for read-only\nor copy-on-write access. An attempt to\nwrite to a specific region results in an\naccess violation.The file handle that\nthe hFile parameter specifies must be\ncreated with the GENERIC_READ access\nright.",0);
	add_enum_member(id,"PAGE_READWRITE",	0X4,	0x4);
	set_enum_member_cmt(get_enum_member(id,0X4,0,0x4),"Allows views to be mapped for read-only,\ncopy-on-write, or read/write access.The\nfile handle that the hFile parameter\nspecifies must be created with the\nGENERIC_READ and GENERIC_WRITE access\nrights.",0);
	add_enum_member(id,"PAGE_WRITECOPY",	0X8,	0x8);
	set_enum_member_cmt(get_enum_member(id,0X8,0,0x8),"Allows views to be mapped for read-only\nor copy-on-write access. This value is\nequivalent to PAGE_READONLY.The file\nhandle that the hFile parameter\nspecifies must be created with the\nGENERIC_READ access right.",0);
	add_enum_member(id,"PAGE_EXECUTE",	0X10,	0x10);
	add_enum_member(id,"PAGE_EXECUTE_READ",	0X20,	0x20);
	set_enum_member_cmt(get_enum_member(id,0X20,0,0x20),"Allows views to be mapped for read-only,\ncopy-on-write, or execute access.The\nfile handle specified by the hFile\nparameter must be created with the\nGENERIC_READ and GENERIC_EXECUTE access\nrights.Windows Server 2003 and Windows\nXP: This value is not available until\nWindows XP with SP2 and Windows Server\n2003 with SP1.Windows 2000: This value\nis not supported.",0);
	add_enum_member(id,"PAGE_EXECUTE_READWRITE",	0X40,	0x40);
	set_enum_member_cmt(get_enum_member(id,0X40,0,0x40),"Allows views to be mapped for read-only,\ncopy-on-write, read/write, or execute\naccess.The file handle that the hFile\nparameter specifies must be created with\nthe GENERIC_READ, GENERIC_WRITE, and\nGENERIC_EXECUTE access rights. Windows\nServer 2003 and Windows XP: This value\nis not available until Windows XP with\nSP2 and Windows Server 2003 with\nSP1.Windows 2000: This value is not\nsupported.",0);
	add_enum_member(id,"PAGE_EXECUTE_WRITECOPY",	0X80,	0x80);
	set_enum_member_cmt(get_enum_member(id,0X80,0,0x80),"Allows views to be mapped for read-only,\ncopy-on-write, or execute access. This\nvalue is equivalent to\nPAGE_EXECUTE_READ.The file handle that\nthe hFile parameter specifies must be\ncreated with the GENERIC_READ and\nGENERIC_EXECUTE access rights. Windows\nServer 2003 and Windows XP/2000: This\nvalue is not supported.Windows Vista:\nThis value is not available until\nWindows Vista with SP1.",0);
	add_enum_member(id,"PAGE_GUARD",	0X100,	0x100);
	add_enum_member(id,"PAGE_NOCACHE",	0X200,	0x200);
	add_enum_member(id,"PAGE_WRITECOMBINE",	0X400,	0x400);
	id = add_enum(-1,"MACRO_TIME_NOMINUTESORSECONDS",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"TIME_NOMINUTESORSECONDS",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"Do not use minutes or seconds.",0);
	add_enum_member(id,"TIME_NOSECONDS",	0X2,	0x2);
	set_enum_member_cmt(get_enum_member(id,0X2,0,0x2),"Do not use seconds.",0);
	add_enum_member(id,"TIME_NOTIMEMARKER",	0X4,	0x4);
	set_enum_member_cmt(get_enum_member(id,0X4,0,0x4),"Do not use a time marker.",0);
	add_enum_member(id,"TIME_FORCE24HOURFORMAT",	0X8,	0x8);
	set_enum_member_cmt(get_enum_member(id,0X8,0,0x8),"Always use a 24-hour time format.",0);
	id = add_enum(-1,"MACRO_CRYPT_VERIFYCONTEXT",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"CRYPT_EXPORTABLE",	0X1,	0x1);
	add_enum_member(id,"CRYPT_USER_PROTECTED",	0X2,	0x2);
	add_enum_member(id,"CRYPT_CREATE_SALT",	0X4,	0x4);
	add_enum_member(id,"CRYPT_NEWKEYSET",	0X8,	0x8);
	set_enum_member_cmt(get_enum_member(id,0X8,0,0x8),"Creates a new key container with the\nname specified by pszContainer. If\npszContainer is NULL, a key container\nwith the default name is created.",0);
	add_enum_member(id,"CRYPT_UPDATE_KEY",	0X8,	0x8);
	add_enum_member(id,"CRYPT_DELETEKEYSET",	0X10,	0x10);
	set_enum_member_cmt(get_enum_member(id,0X10,0,0x10),"Delete the key container specified by\npszContainer. If pszContainer is NULL,\nthe key container with the default name\nis deleted. All key pairs in the key\ncontainer are also destroyed. When this\nflag is set, the value returned in\nphProv is undefined, and thus, the\nCryptReleaseContext function need not be\ncalled afterward.",0);
	add_enum_member(id,"CRYPT_NO_SALT",	0X10,	0x10);
	add_enum_member(id,"CRYPT_RECIPIENT",	0X10,	0x10);
	add_enum_member(id,"CRYPT_MACHINE_KEYSET",	0X20,	0x20);
	set_enum_member_cmt(get_enum_member(id,0X20,0,0x20),"By default, keys and key containers are\nstored as user keys. For Base Providers,\nthis means that user key containers are\nstored in the user's profile. A key\ncontainer created without this flag by\nan administrator can be accessed only by\nthe user creating the key container and\na user with administration\nprivileges.Windows XP: A key container\ncreated without this flag by an\nadministrator can be accessed only by\nthe user creating the key container and\nthe local system account.A key container\ncreated without this flag by a user that\nis not an administrator can be accessed\nonly by the user creating the key\ncontainer and the local system\naccount.The CRYPT_MACHINE_KEYSET flag\ncan be combined with all of the other\nflags to indicate that the key container\nof interest is a computer key container\nand the CSP treats it as such. For Base\nProviders, this means that the keys are\nstored locally on the computer that\ncreated the key container. If a key\ncontainer is to be a computer container,\nthe CRYPT_MACHINE_KEYSET flag mus" "t",0);
	add_enum_member(id,"CRYPT_PREGEN",	0X40,	0x40);
	add_enum_member(id,"CRYPT_INITIATOR",	0X40,	0x40);
	add_enum_member(id,"CRYPT_ONLINE",	0X80,	0x80);
	add_enum_member(id,"CRYPT_SF",	0X100,	0x100);
	add_enum_member(id,"CRYPT_CREATE_IV",	0X200,	0x200);
	add_enum_member(id,"CRYPT_KEK",	0X400,	0x400);
	add_enum_member(id,"CRYPT_SERVER",	0X400,	0x400);
	add_enum_member(id,"CRYPT_DATA_KEY",	0X800,	0x800);
	add_enum_member(id,"CRYPT_VERIFYCONTEXT",	0XF0000000,	0xF0000000);
	set_enum_member_cmt(get_enum_member(id,0XF0000000,0,0xF0000000),"This option is intended for applications\nthat are using ephemeral keys, or\napplications that do not require access\nto persisted private keys, such as\napplications that perform only hashing,\nencryption, and digital signature\nverification. Only applications that\ncreate signatures or decrypt messages\nneed access to a private key. In most\ncases, this flag should be set.For file-\nbased CSPs, when this flag is set, the\npszContainer parameter must be set to\nNULL. The application has no access to\nthe persisted private keys of\npublic/private key pairs. When this flag\nis set, temporary public/private key\npairs can be created, but they are not\npersisted.For hardware-based CSPs, such\nas a smart card CSP, if the pszContainer\nparameter is NULL or blank, this flag\nimplies that no access to any keys is\nrequired, and that no UI should be\npresented to the user. This form is used\nto connect to the CSP to query its\ncapabilities but not to actually use its\nkeys.If the pszContainer parameter is\nnot NULL and not blank, then this f" "l",0);
	id = add_enum(-1,"MACRO_FIND",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"FIND_FIRST_EX_CASE_SENSITIVE",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"Searches are case-sensitive.",0);
	id = add_enum(-1,"MACRO_HP",0x1100000);
	add_enum_member(id,"HP_ALGID",	0X1,	-1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,-1),"An ALG_ID that indicates the algorithm\nspecified when the hash object was\ncreated. For a list of hash algorithms,\nsee CryptCreateHash.",0);
	add_enum_member(id,"HP_HASHVAL",	0X2,	-1);
	set_enum_member_cmt(get_enum_member(id,0X2,0,-1),"The hash value or message hash for the\nhash object specified by hHash. This\nvalue is generated based on the data\nsupplied to the hash object earlier\nthrough the CryptHashData and\nCryptHashSessionKey functions.The\nCryptGetHashParam function completes the\nhash. After CryptGetHashParam has been\ncalled, no more data can be added to the\nhash. Additional calls to CryptHashData\nor CryptHashSessionKey fail. After the\napplication is done with the hash,\nCryptDestroyHash should be called to\ndestroy the hash object.",0);
	add_enum_member(id,"HP_HASHSIZE",	0X4,	-1);
	set_enum_member_cmt(get_enum_member(id,0X4,0,-1),"DWORD value indicating the number of\nbytes in the hash value. This value will\nusually be 16 or 20, depending on the\nhash algorithm. Applications must\nretrieve this value just before the\nHP_HASHVAL value so the correct amount\nof memory can be allocated.",0);
	add_enum_member(id,"HP_HMAC_INFO",	0X5,	-1);
	id = add_enum(-1,"MACRO_CREATE",0x2220000);
	set_enum_bf(id,1);
	add_enum_member(id,"CREATE_NEW",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"Creates a new file, only if it does not\nalready exist.If the specified file\nexists, the function fails and the last-\nerror code is set to ERROR_FILE_EXISTS\n(80).If the specified file does not\nexist and is a valid path to a writable\nlocation, a new file is created.",0);
	add_enum_member(id,"CREATE_ALWAYS",	0X2,	0x2);
	set_enum_member_cmt(get_enum_member(id,0X2,0,0x2),"Creates a new file, always.If the\nspecified file exists and is writable,\nthe function overwrites the file, the\nfunction succeeds, and last-error code\nis set to ERROR_ALREADY_EXISTS (183).If\nthe specified file does not exist and is\na valid path, a new file is created, the\nfunction succeeds, and the last-error\ncode is set to zero.For more\ninformation, see the Remarks section of\nthis topic.",0);
	id = add_enum(-1,"MACRO_FILE_FLAG",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"FILE_FLAG_OPEN_NO_RECALL",	0X100000,	0x100000);
	set_enum_member_cmt(get_enum_member(id,0X100000,0,0x100000),"The file data is requested, but it\nshould continue to be located in remote\nstorage. It should not be transported\nback to local storage. This flag is for\nuse by remote storage systems.",0);
	add_enum_member(id,"FILE_FLAG_OPEN_REPARSE_POINT",	0X200000,	0x200000);
	set_enum_member_cmt(get_enum_member(id,0X200000,0,0x200000),"Normal reparse point processing will not\noccur; CreateFile will attempt to open\nthe reparse point. When a file is\nopened, a file handle is returned,\nwhether or not the filter that controls\nthe reparse point is operational. This\nflag cannot be used with the\nCREATE_ALWAYS flag. If the file is not a\nreparse point, then this flag is\nignored.For more information, see the\nRemarks section.",0);
	add_enum_member(id,"FILE_FLAG_POSIX_SEMANTICS",	0X1000000,	0x1000000);
	set_enum_member_cmt(get_enum_member(id,0X1000000,0,0x1000000),"Access will occur according to POSIX\nrules. This includes allowing multiple\nfiles with names, differing only in\ncase, for file systems that support that\nnaming. Use care when using this option,\nbecause files created with this flag may\nnot be accessible by applications that\nare written for MS-DOS or 16-bit\nWindows.",0);
	add_enum_member(id,"FILE_FLAG_BACKUP_SEMANTICS",	0X2000000,	0x2000000);
	set_enum_member_cmt(get_enum_member(id,0X2000000,0,0x2000000),"The file is being opened or created for\na backup or restore operation. The\nsystem ensures that the calling process\noverrides file security checks when the\nprocess has SE_BACKUP_NAME and\nSE_RESTORE_NAME privileges. For more\ninformation, see Changing Privileges in\na Token.You must set this flag to obtain\na handle to a directory. A directory\nhandle can be passed to some functions\ninstead of a file handle. For more\ninformation, see the Remarks section.",0);
	add_enum_member(id,"FILE_FLAG_DELETE_ON_CLOSE",	0X4000000,	0x4000000);
	set_enum_member_cmt(get_enum_member(id,0X4000000,0,0x4000000),"The file is to be deleted immediately\nafter all of its handles are closed,\nwhich includes the specified handle and\nany other open or duplicated handles.If\nthere are existing open handles to a\nfile, the call fails unless they were\nall opened with the FILE_SHARE_DELETE\nshare mode.Subsequent open requests for\nthe file fail, unless the\nFILE_SHARE_DELETE share mode is\nspecified.",0);
	add_enum_member(id,"FILE_FLAG_SEQUENTIAL_SCAN",	0X8000000,	0x8000000);
	set_enum_member_cmt(get_enum_member(id,0X8000000,0,0x8000000),"Access is intended to be sequential from\nbeginning to end. The system can use\nthis as a hint to optimize file caching.\nThis flag should not be used if read-\nbehind (that is, backwards scans) will\nbe used.This flag has no effect if the\nfile system does not support cached I/O\nand FILE_FLAG_NO_BUFFERING.For more\ninformation, see the Caching Behavior\nsection of this topic.",0);
	add_enum_member(id,"FILE_FLAG_RANDOM_ACCESS",	0X10000000,	0x10000000);
	set_enum_member_cmt(get_enum_member(id,0X10000000,0,0x10000000),"Access is intended to be random. The\nsystem can use this as a hint to\noptimize file caching.This flag has no\neffect if the file system does not\nsupport cached I/O and\nFILE_FLAG_NO_BUFFERING.For more\ninformation, see the Caching Behavior\nsection of this topic.",0);
	add_enum_member(id,"FILE_FLAG_NO_BUFFERING",	0X20000000,	0x20000000);
	set_enum_member_cmt(get_enum_member(id,0X20000000,0,0x20000000),"The file or device is being opened with\nno system caching for data reads and\nwrites. This flag does not affect hard\ndisk caching or memory mapped\nfiles.There are strict requirements for\nsuccessfully working with files opened\nwith CreateFile using the\nFILE_FLAG_NO_BUFFERING flag, for details\nsee File Buffering.",0);
	add_enum_member(id,"FILE_FLAG_OVERLAPPED",	0X40000000,	0x40000000);
	set_enum_member_cmt(get_enum_member(id,0X40000000,0,0x40000000),"The file or device is being opened or\ncreated for asynchronous I/O. When\nsubsequent I/O operations are completed\non this handle, the event specified in\nthe OVERLAPPED structure will be set to\nthe signaled state.If this flag is\nspecified, the file can be used for\nsimultaneous read and write\noperations.If this flag is not\nspecified, then I/O operations are\nserialized, even if the calls to the\nread and write functions specify an\nOVERLAPPED structure.For information\nabout considerations when using a file\nhandle created with this flag, see the\nSynchronous and Asynchronous I/O Handles\nsection of this topic.",0);
	add_enum_member(id,"FILE_FLAG_WRITE_THROUGH",	0X80000000,	0x80000000);
	set_enum_member_cmt(get_enum_member(id,0X80000000,0,0x80000000),"Write operations will not go through any\nintermediate cache, they will go\ndirectly to disk.For additional\ninformation, see the Caching Behavior\nsection of this topic.",0);
	id = add_enum(-1,"MACRO_SECURITY_CONTEXT",0x1100000);
	add_enum_member(id,"SECURITY_CONTEXT_TRACKING",	0X40000,	-1);
	set_enum_member_cmt(get_enum_member(id,0X40000,0,-1),"The security tracking mode is dynamic.\nIf this flag is not specified, the\nsecurity tracking mode is static.",0);
	add_enum_member(id,"SECURITY_EFFECTIVE_ONLY",	0X80000,	-1);
	set_enum_member_cmt(get_enum_member(id,0X80000,0,-1),"Only the enabled aspects of the client's\nsecurity context are available to the\nserver. If you do not specify this flag,\nall aspects of the client's security\ncontext are available.This allows the\nclient to limit the groups and\nprivileges that a server can use while\nimpersonating the client.",0);
	add_enum_member(id,"SECURITY_SQOS_PRESENT",	0X100000,	-1);
	add_enum_member(id,"SECURITY_VALID_SQOS_FLAGS",	0X1F0000,	-1);
	id = add_enum(-1,"MACRO_CP_INSTALLED",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"CP_INSTALLED",	0X1,	0x1);
	add_enum_member(id,"CP_SUPPORTED",	0X2,	0x2);
	id = add_enum(-1,"MACRO_LCMAP",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"LCMAP_LOWERCASE",	0X100,	0x100);
	set_enum_member_cmt(get_enum_member(id,0X100,0,0x100),"For locales and scripts capable of\nhandling uppercase and lowercase, map\nall characters to lowercase.",0);
	add_enum_member(id,"LCMAP_UPPERCASE",	0X200,	0x200);
	set_enum_member_cmt(get_enum_member(id,0X200,0,0x200),"For locales and scripts capable of\nhandling uppercase and lowercase, map\nall characters to uppercase.",0);
	add_enum_member(id,"LCMAP_SORTKEY",	0X400,	0x400);
	set_enum_member_cmt(get_enum_member(id,0X400,0,0x400),"Produce a normalized sort key. If the\nLCMAP_SORTKEY flag is not specified, the\nfunction performs string mapping. For\ndetails of sort key generation and\nstring mapping, see the Remarks section.",0);
	add_enum_member(id,"LCMAP_BYTEREV",	0X800,	0x800);
	set_enum_member_cmt(get_enum_member(id,0X800,0,0x800)," Use byte reversal. For example, if the\napplication passes in 0x3450 0x4822, the\nresult is 0x5034 0x2248.",0);
	add_enum_member(id,"LCMAP_HIRAGANA",	0X100000,	0x100000);
	set_enum_member_cmt(get_enum_member(id,0X100000,0,0x100000),"Map all katakana characters to hiragana.\nThis flag and LCMAP_KATAKANA are\nmutually exclusive.",0);
	add_enum_member(id,"LCMAP_KATAKANA",	0X200000,	0x200000);
	set_enum_member_cmt(get_enum_member(id,0X200000,0,0x200000),"Map all hiragana characters to katakana.\nThis flag and LCMAP_HIRAGANA are\nmutually exclusive.",0);
	add_enum_member(id,"LCMAP_HALFWIDTH",	0X400000,	0x400000);
	set_enum_member_cmt(get_enum_member(id,0X400000,0,0x400000),"Use narrow characters where applicable.\nThis flag and LCMAP_FULLWIDTH are\nmutually exclusive.",0);
	add_enum_member(id,"LCMAP_FULLWIDTH",	0X800000,	0x800000);
	set_enum_member_cmt(get_enum_member(id,0X800000,0,0x800000),"Use Unicode (wide) characters where\napplicable. This flag and\nLCMAP_HALFWIDTH are mutually exclusive.",0);
	add_enum_member(id,"LCMAP_LINGUISTIC_CASING",	0X1000000,	0x1000000);
	set_enum_member_cmt(get_enum_member(id,0X1000000,0,0x1000000)," Use linguistic rules for casing,\ninstead of file system rules (default).\nThis flag is valid with LCMAP_LOWERCASE\nor LCMAP_UPPERCASE only.",0);
	add_enum_member(id,"LCMAP_SIMPLIFIED_CHINESE",	0X2000000,	0x2000000);
	set_enum_member_cmt(get_enum_member(id,0X2000000,0,0x2000000),"Map traditional Chinese characters to\nsimplified Chinese characters. This flag\nand LCMAP_TRADITIONAL_CHINESE are\nmutually exclusive.",0);
	add_enum_member(id,"LCMAP_TRADITIONAL_CHINESE",	0X4000000,	0x4000000);
	set_enum_member_cmt(get_enum_member(id,0X4000000,0,0x4000000),"Map simplified Chinese characters to\ntraditional Chinese characters. This\nflag and LCMAP_SIMPLIFIED_CHINESE are\nmutually exclusive.",0);
	id = add_enum(-1,"MACRO_C3",0x1100000);
	add_enum_member(id,"C3_NOTAPPLICABLE",	0,	-1);
	add_enum_member(id,"C3_NONSPACING",	0X1,	-1);
	add_enum_member(id,"C3_DIACRITIC",	0X2,	-1);
	add_enum_member(id,"C3_VOWELMARK",	0X4,	-1);
	add_enum_member(id,"C3_SYMBOL",	0X8,	-1);
	add_enum_member(id,"C3_KATAKANA",	0X10,	-1);
	add_enum_member(id,"C3_HIRAGANA",	0X20,	-1);
	add_enum_member(id,"C3_HALFWIDTH",	0X40,	-1);
	add_enum_member(id,"C3_FULLWIDTH",	0X80,	-1);
	add_enum_member(id,"C3_IDEOGRAPH",	0X100,	-1);
	add_enum_member(id,"C3_KASHIDA",	0X200,	-1);
	add_enum_member(id,"C3_LEXICAL",	0X400,	-1);
	add_enum_member(id,"C3_ALPHA",	0X8000,	-1);
	id = add_enum(-1,"MACRO_CRYPT_USERDATA",0x2220000);
	set_enum_bf(id,1);
	add_enum_member(id,"CRYPT_USERDATA",	0X1,	0x1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,0x1),"All Microsoft Cryptographic Providers\nignore this parameter. For any CSP that\ndoes not ignore this parameter, if this\nflag is set, the CSP prompts the user to\ninput data directly. This data is added\nto the hash. The application is not\nallowed access to the data. This flag\ncan be used to allow the user to enter a\nPIN into the system.",0);
	id = add_enum(-1,"MACRO_WC",0x1100000);
	set_enum_bf(id,1);
	add_enum_member(id,"WC_DIALOG",	0X8002,	0x8002);
	id = add_enum(-1,"MACRO_VER_EQUAL",0x2220000);
	add_enum_member(id,"VER_PLATFORM_WIN32s",	0,	-1);
	add_enum_member(id,"VER_EQUAL",	0X1,	-1);
	set_enum_member_cmt(get_enum_member(id,0X1,0,-1),"The current value must be equal to the\nspecified value.",0);
	add_enum_member(id,"VER_MINORVERSION",	0X1,	-1);
	add_enum_member(id,"VER_NT_WORKSTATION",	0X1,	-1);
	add_enum_member(id,"VER_PLATFORM_WIN32_WINDOWS",	0X1,	-1);
	add_enum_member(id,"VER_GREATER",	0X2,	-1);
	set_enum_member_cmt(get_enum_member(id,0X2,0,-1),"The current value must be greater than\nthe specified value.",0);
	add_enum_member(id,"VER_MAJORVERSION",	0X2,	-1);
	add_enum_member(id,"VER_NT_DOMAIN_CONTROLLER",	0X2,	-1);
	add_enum_member(id,"VER_PLATFORM_WIN32_NT",	0X2,	-1);
	add_enum_member(id,"VER_GREATER_EQUAL",	0X3,	-1);
	set_enum_member_cmt(get_enum_member(id,0X3,0,-1),"The current value must be greater than\nor equal to the specified value.",0);
	add_enum_member(id,"VER_NUM_BITS_PER_CONDITION_MASK",	0X3,	-1);
	add_enum_member(id,"VER_NT_SERVER",	0X3,	-1);
	add_enum_member(id,"VER_LESS",	0X4,	-1);
	set_enum_member_cmt(get_enum_member(id,0X4,0,-1),"The current value must be less than the\nspecified value.",0);
	add_enum_member(id,"VER_BUILDNUMBER",	0X4,	-1);
	add_enum_member(id,"VER_LESS_EQUAL",	0X5,	-1);
	set_enum_member_cmt(get_enum_member(id,0X5,0,-1),"The current value must be less than or\nequal to the specified value.",0);
	add_enum_member(id,"VER_AND",	0X6,	-1);
	set_enum_member_cmt(get_enum_member(id,0X6,0,-1),"All product suites specified in the\nwSuiteMask member must be present in the\ncurrent system.",0);
	add_enum_member(id,"VER_OR",	0X7,	-1);
	set_enum_member_cmt(get_enum_member(id,0X7,0,-1),"At least one of the specified product\nsuites must be present in the current\nsystem.",0);
	add_enum_member(id,"VER_CONDITION_MASK",	0X7,	-1);
	add_enum_member(id,"VER_PLATFORMID",	0X8,	-1);
	add_enum_member(id,"VER_SERVICEPACKMINOR",	0X10,	-1);
	add_enum_member(id,"VER_SERVICEPACKMAJOR",	0X20,	-1);
	add_enum_member(id,"VER_SUITENAME",	0X40,	-1);
	add_enum_member(id,"VER_PRODUCT_TYPE",	0X80,	-1);
	id = add_enum(-1,"_GET_FILEEX_INFO_LEVELS",0x1100000);
	set_enum_bf(id,1);
	id = add_enum(-1,"MACRO_FILE_TYPE",0x1100000);
	add_enum_member(id,"FILE_TYPE_UNKNOWN",	0,	-1);
	add_enum_member(id,"FILE_TYPE_DISK",	0X1,	-1);
	add_enum_member(id,"FILE_TYPE_CHAR",	0X2,	-1);
	add_enum_member(id,"FILE_TYPE_PIPE",	0X3,	-1);
	add_enum_member(id,"FILE_TYPE_REMOTE",	0X8000,	-1);
	id = add_enum(-1,"MACRO_STD",0x2220000);
	add_enum_member(id,"STD_ERROR_HANDLE",	0XFFFFFFF4,	-1);
	add_enum_member(id,"STD_OUTPUT_HANDLE",	0XFFFFFFF5,	-1);
	add_enum_member(id,"STD_INPUT_HANDLE",	0XFFFFFFF6,	-1);
	id = add_enum(-1,"browser_dumpwd_parson",0x1100000);
	add_enum_member(id,"STARTING_CAPACITY",	0XF,	-1);
	add_enum_member(id,"MAX_NESTING",	0X13,	-1);
	add_enum_member(id,"OBJECT_MAX_CAPACITY",	0X3C0,	-1);
	add_enum_member(id,"ARRAY_MAX_CAPACITY",	0X1E000,	-1);
	id = add_enum(-1,"zip",0x1100000);
	add_enum_member(id,"ZIP_DEFAULT_COMPRESSION_LEVEL",	0X6,	-1);
	return id;
}

//------------------------------------------------------------------------
// Information about enum types

static Enums(void) {
        auto id;
        begin_type_updating(UTP_ENUM);
	id = Enums_0(id);
        end_type_updating(UTP_ENUM);
}

static ApplyStrucTInfos_0(void) {
        auto id;
	id = get_struc_id("GUID");
	SetType(get_member_id(id, 0x0), "unsigned int");
	SetType(get_member_id(id, 0x4), "unsigned __int16");
	SetType(get_member_id(id, 0x6), "unsigned __int16");
	SetType(get_member_id(id, 0x8), "unsigned __int8[8]");
	id = get_struc_id("_EH4_SCOPETABLE");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "DWORD");
	SetType(get_member_id(id, 0x8), "DWORD");
	SetType(get_member_id(id, 0xC), "DWORD");
	SetType(get_member_id(id, 0x10), "struct _EH4_SCOPETABLE_RECORD[]");
	id = get_struc_id("_EH4_SCOPETABLE_RECORD");
	SetType(get_member_id(id, 0x0), "int");
	SetType(get_member_id(id, 0x4), "void *");
	SetType(get_member_id(id, 0x8), "void *");
	id = get_struc_id("CPPEH_RECORD");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "EXCEPTION_POINTERS *");
	SetType(get_member_id(id, 0x8), "struct _EH3_EXCEPTION_REGISTRATION");
	id = get_struc_id("_EH3_EXCEPTION_REGISTRATION");
	SetType(get_member_id(id, 0x0), "struct _EH3_EXCEPTION_REGISTRATION *");
	SetType(get_member_id(id, 0x4), "PVOID");
	SetType(get_member_id(id, 0x8), "PSCOPETABLE_ENTRY");
	SetType(get_member_id(id, 0xC), "DWORD");
	id = get_struc_id("DATA_BLOB");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "BYTE *");
	id = get_struc_id("_RTL_CRITICAL_SECTION");
	SetType(get_member_id(id, 0x0), "PRTL_CRITICAL_SECTION_DEBUG");
	SetType(get_member_id(id, 0x4), "LONG");
	SetType(get_member_id(id, 0x8), "LONG");
	SetType(get_member_id(id, 0xC), "HANDLE");
	SetType(get_member_id(id, 0x10), "HANDLE");
	SetType(get_member_id(id, 0x14), "DWORD");
	id = get_struc_id("_SYSTEM_INFO");
	SetType(get_member_id(id, 0x0), "_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F");
	SetType(get_member_id(id, 0x4), "DWORD");
	SetType(get_member_id(id, 0x8), "LPVOID");
	SetType(get_member_id(id, 0xC), "LPVOID");
	SetType(get_member_id(id, 0x10), "DWORD");
	SetType(get_member_id(id, 0x14), "DWORD");
	SetType(get_member_id(id, 0x18), "DWORD");
	SetType(get_member_id(id, 0x1C), "DWORD");
	SetType(get_member_id(id, 0x20), "WORD");
	SetType(get_member_id(id, 0x22), "WORD");
	id = get_struc_id("_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x1), "_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F::$AA04DEB0C6383F89F13D312A174572A9");
	id = get_struc_id("_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F::$AA04DEB0C6383F89F13D312A174572A9");
	SetType(get_member_id(id, 0x0), "WORD");
	SetType(get_member_id(id, 0x2), "WORD");
	id = get_struc_id("_OVERLAPPED");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "DWORD");
	SetType(get_member_id(id, 0x8), "DWORD");
	SetType(get_member_id(id, 0xC), "DWORD");
	SetType(get_member_id(id, 0x10), "HANDLE");
	id = get_struc_id("_FILETIME");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "DWORD");
	id = get_struc_id("LARGE_INTEGER");
	SetType(get_member_id(id, 0x0), "_LARGE_INTEGER::$837407842DC9087486FDFA5FEB63B74E");
	SetType(get_member_id(id, 0x1), "_LARGE_INTEGER::$837407842DC9087486FDFA5FEB63B74E");
	SetType(get_member_id(id, 0x2), "LONGLONG");
	id = get_struc_id("_LARGE_INTEGER::$837407842DC9087486FDFA5FEB63B74E");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "LONG");
	id = get_struc_id("_EXCEPTION_POINTERS");
	SetType(get_member_id(id, 0x0), "PEXCEPTION_RECORD");
	SetType(get_member_id(id, 0x4), "PCONTEXT");
	id = get_struc_id("WSAData");
	SetType(get_member_id(id, 0x0), "WORD");
	SetType(get_member_id(id, 0x2), "WORD");
	SetType(get_member_id(id, 0x4), "char[257]");
	SetType(get_member_id(id, 0x105), "char[129]");
	SetType(get_member_id(id, 0x186), "unsigned __int16");
	SetType(get_member_id(id, 0x188), "unsigned __int16");
	SetType(get_member_id(id, 0x18C), "char *");
	id = get_struc_id("_OSVERSIONINFOEXA");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "DWORD");
	SetType(get_member_id(id, 0x8), "DWORD");
	SetType(get_member_id(id, 0xC), "DWORD");
	SetType(get_member_id(id, 0x10), "DWORD");
	SetType(get_member_id(id, 0x14), "CHAR[128]");
	SetType(get_member_id(id, 0x94), "WORD");
	SetType(get_member_id(id, 0x96), "WORD");
	SetType(get_member_id(id, 0x98), "WORD[2]");
	id = get_struc_id("fd_set");
	SetType(get_member_id(id, 0x0), "u_int");
	SetType(get_member_id(id, 0x4), "SOCKET[64]");
	id = get_struc_id("sockaddr");
	SetType(get_member_id(id, 0x0), "u_short");
	SetType(get_member_id(id, 0x2), "char[14]");
	id = get_struc_id("_WIN32_FIND_DATAW");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "FILETIME");
	SetType(get_member_id(id, 0xC), "FILETIME");
	SetType(get_member_id(id, 0x14), "FILETIME");
	SetType(get_member_id(id, 0x1C), "DWORD");
	SetType(get_member_id(id, 0x20), "DWORD");
	SetType(get_member_id(id, 0x24), "DWORD");
	SetType(get_member_id(id, 0x28), "DWORD");
	SetType(get_member_id(id, 0x2C), "WCHAR[260]");
	SetType(get_member_id(id, 0x234), "WCHAR[14]");
	id = get_struc_id("FILETIME");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "DWORD");
	id = get_struc_id("_SYSTEMTIME");
	SetType(get_member_id(id, 0x0), "WORD");
	SetType(get_member_id(id, 0x2), "WORD");
	SetType(get_member_id(id, 0x4), "WORD");
	SetType(get_member_id(id, 0x6), "WORD");
	SetType(get_member_id(id, 0x8), "WORD");
	SetType(get_member_id(id, 0xA), "WORD");
	SetType(get_member_id(id, 0xC), "WORD");
	SetType(get_member_id(id, 0xE), "WORD");
	id = get_struc_id("_BY_HANDLE_FILE_INFORMATION");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "FILETIME");
	SetType(get_member_id(id, 0xC), "FILETIME");
	SetType(get_member_id(id, 0x14), "FILETIME");
	SetType(get_member_id(id, 0x1C), "DWORD");
	SetType(get_member_id(id, 0x20), "DWORD");
	SetType(get_member_id(id, 0x24), "DWORD");
	SetType(get_member_id(id, 0x28), "DWORD");
	SetType(get_member_id(id, 0x2C), "DWORD");
	SetType(get_member_id(id, 0x30), "DWORD");
	id = get_struc_id("SYSTEMTIME");
	SetType(get_member_id(id, 0x0), "WORD");
	SetType(get_member_id(id, 0x2), "WORD");
	SetType(get_member_id(id, 0x4), "WORD");
	SetType(get_member_id(id, 0x6), "WORD");
	SetType(get_member_id(id, 0x8), "WORD");
	SetType(get_member_id(id, 0xA), "WORD");
	SetType(get_member_id(id, 0xC), "WORD");
	SetType(get_member_id(id, 0xE), "WORD");
	id = get_struc_id("_TIME_ZONE_INFORMATION");
	SetType(get_member_id(id, 0x0), "LONG");
	SetType(get_member_id(id, 0x4), "WCHAR[32]");
	SetType(get_member_id(id, 0x44), "SYSTEMTIME");
	SetType(get_member_id(id, 0x54), "LONG");
	SetType(get_member_id(id, 0x58), "WCHAR[32]");
	SetType(get_member_id(id, 0x98), "SYSTEMTIME");
	SetType(get_member_id(id, 0xA8), "LONG");
	id = get_struc_id("_cpinfo");
	SetType(get_member_id(id, 0x0), "UINT");
	SetType(get_member_id(id, 0x4), "BYTE[2]");
	SetType(get_member_id(id, 0x6), "BYTE[12]");
	id = get_struc_id("_SLIST_HEADER");
	SetType(get_member_id(id, 0x0), "ULONGLONG");
	SetType(get_member_id(id, 0x1), "_SLIST_HEADER::$83AF6D9DC8E3B10431D79B304957BA23");
	id = get_struc_id("_SLIST_HEADER::$83AF6D9DC8E3B10431D79B304957BA23");
	SetType(get_member_id(id, 0x0), "SINGLE_LIST_ENTRY");
	SetType(get_member_id(id, 0x4), "WORD");
	SetType(get_member_id(id, 0x6), "WORD");
	id = get_struc_id("SINGLE_LIST_ENTRY");
	SetType(get_member_id(id, 0x0), "_SINGLE_LIST_ENTRY *");
	id = get_struc_id("_STARTUPINFOW");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "LPWSTR");
	SetType(get_member_id(id, 0x8), "LPWSTR");
	SetType(get_member_id(id, 0xC), "LPWSTR");
	SetType(get_member_id(id, 0x10), "DWORD");
	SetType(get_member_id(id, 0x14), "DWORD");
	SetType(get_member_id(id, 0x18), "DWORD");
	SetType(get_member_id(id, 0x1C), "DWORD");
	SetType(get_member_id(id, 0x20), "DWORD");
	SetType(get_member_id(id, 0x24), "DWORD");
	SetType(get_member_id(id, 0x28), "DWORD");
	SetType(get_member_id(id, 0x2C), "DWORD");
	SetType(get_member_id(id, 0x30), "WORD");
	SetType(get_member_id(id, 0x32), "WORD");
	SetType(get_member_id(id, 0x34), "LPBYTE");
	SetType(get_member_id(id, 0x38), "HANDLE");
	SetType(get_member_id(id, 0x3C), "HANDLE");
	SetType(get_member_id(id, 0x40), "HANDLE");
	id = get_struc_id("_SECURITY_ATTRIBUTES");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "LPVOID");
	SetType(get_member_id(id, 0x8), "BOOL");
	id = get_struc_id("ADDRINFOA");
	SetType(get_member_id(id, 0x0), "int");
	SetType(get_member_id(id, 0x4), "int");
	SetType(get_member_id(id, 0x8), "int");
	SetType(get_member_id(id, 0xC), "int");
	SetType(get_member_id(id, 0x10), "size_t");
	SetType(get_member_id(id, 0x14), "char *");
	SetType(get_member_id(id, 0x18), "sockaddr *");
	SetType(get_member_id(id, 0x1C), "addrinfo *");
	id = get_struc_id("FuncInfo");
	id = get_struc_id("UnwindMapEntry");
	id = get_struc_id("TryBlockMapEntry");
	id = get_struc_id("HandlerType");
	id = get_struc_id("JSON_Value_Value");
	SetType(get_member_id(id, 0x0), "char *");
	SetType(get_member_id(id, 0x1), "double");
	SetType(get_member_id(id, 0x2), "JSON_Object *");
	SetType(get_member_id(id, 0x3), "JSON_Array *");
	SetType(get_member_id(id, 0x4), "int");
	SetType(get_member_id(id, 0x5), "int");
	id = get_struc_id("JSON_Value");
	SetType(get_member_id(id, 0x0), "JSON_Value_Type");
	SetType(get_member_id(id, 0x8), "JSON_Value_Value");
	id = get_struc_id("JSON_Object");
	SetType(get_member_id(id, 0x0), "char **");
	SetType(get_member_id(id, 0x4), "JSON_Value **");
	SetType(get_member_id(id, 0x8), "size_t");
	SetType(get_member_id(id, 0xC), "size_t");
	id = get_struc_id("__m128i");
	SetType(get_member_id(id, 0x0), "__int8[16]");
	SetType(get_member_id(id, 0x1), "__int16[8]");
	SetType(get_member_id(id, 0x2), "__int32[4]");
	SetType(get_member_id(id, 0x3), "__int64[2]");
	SetType(get_member_id(id, 0x4), "unsigned __int8[16]");
	SetType(get_member_id(id, 0x5), "unsigned __int16[8]");
	SetType(get_member_id(id, 0x6), "unsigned __int32[4]");
	SetType(get_member_id(id, 0x7), "unsigned __int64[2]");
	id = get_struc_id("_WIN32_FIND_DATAA");
	SetType(get_member_id(id, 0x0), "DWORD");
	SetType(get_member_id(id, 0x4), "FILETIME");
	SetType(get_member_id(id, 0xC), "FILETIME");
	SetType(get_member_id(id, 0x14), "FILETIME");
	SetType(get_member_id(id, 0x1C), "DWORD");
	SetType(get_member_id(id, 0x20), "DWORD");
	SetType(get_member_id(id, 0x24), "DWORD");
	SetType(get_member_id(id, 0x28), "DWORD");
	SetType(get_member_id(id, 0x2C), "CHAR[260]");
	SetType(get_member_id(id, 0x130), "CHAR[14]");
	return id;
}

//------------------------------------------------------------------------
// Information about type information for structure members

static ApplyStrucTInfos() {
	ApplyStrucTInfos_0();
}

static Structures_0(id) {
        auto mid;

	id = add_struc(-1,"GUID",0);
	id = add_struc(-1,"_EH4_SCOPETABLE",0);
	id = add_struc(-1,"_EH4_SCOPETABLE_RECORD",0);
	id = add_struc(-1,"CPPEH_RECORD",0);
	id = add_struc(-1,"_EH3_EXCEPTION_REGISTRATION",0);
	id = add_struc(-1,"DATA_BLOB",0);
	id = add_struc(-1,"_RTL_CRITICAL_SECTION",0);
	id = add_struc(-1,"_SYSTEM_INFO",0);
	id = add_struc(-1,"_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F",1);
	id = add_struc(-1,"_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F::$AA04DEB0C6383F89F13D312A174572A9",0);
	id = add_struc(-1,"_OVERLAPPED",0);
	id = add_struc(-1,"_FILETIME",0);
	id = add_struc(-1,"LARGE_INTEGER",1);
	id = add_struc(-1,"_LARGE_INTEGER::$837407842DC9087486FDFA5FEB63B74E",0);
	id = add_struc(-1,"_EXCEPTION_POINTERS",0);
	id = add_struc(-1,"WSAData",0);
	id = add_struc(-1,"_OSVERSIONINFOEXA",0);
	id = add_struc(-1,"fd_set",0);
	id = add_struc(-1,"sockaddr",0);
	id = add_struc(-1,"_WIN32_FIND_DATAW",0);
	id = add_struc(-1,"FILETIME",0);
	id = add_struc(-1,"_SYSTEMTIME",0);
	set_struc_cmt(id,"Specifies a date and time, using\nindividual members for the month, day,\nyear, weekday, hour, minute, second, and\nmillisecond. The time is either in\ncoordinated universal time (UTC) or\nlocal time, depending on the function\nthat is being called.\n",0);
	id = add_struc(-1,"_BY_HANDLE_FILE_INFORMATION",0);
	id = add_struc(-1,"SYSTEMTIME",0);
	id = add_struc(-1,"_TIME_ZONE_INFORMATION",0);
	id = add_struc(-1,"_cpinfo",0);
	id = add_struc(-1,"_SLIST_HEADER",1);
	id = add_struc(-1,"_SLIST_HEADER::$83AF6D9DC8E3B10431D79B304957BA23",0);
	id = add_struc(-1,"SINGLE_LIST_ENTRY",0);
	id = add_struc(-1,"_STARTUPINFOW",0);
	id = add_struc(-1,"_SECURITY_ATTRIBUTES",0);
	id = add_struc(-1,"ADDRINFOA",0);
	id = add_struc(-1,"FuncInfo",0);
	id = add_struc(-1,"UnwindMapEntry",0);
	id = add_struc(-1,"TryBlockMapEntry",0);
	id = add_struc(-1,"HandlerType",0);
	id = add_struc(-1,"JSON_Value_Value",1);
	id = add_struc(-1,"JSON_Value",0);
	id = add_struc(-1,"JSON_Object",0);
	id = add_struc(-1,"__m128i",1);
	id = add_struc(-1,"_WIN32_FIND_DATAA",0);
	
	id = get_struc_id("GUID");
	mid = add_struc_member(id,"Data1",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"Data2",	0X4,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"Data3",	0X6,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"Data4",	0X8,	0x000400,	-1,	8);
	set_struc_align(id,2);
	
	id = get_struc_id("_EH4_SCOPETABLE_RECORD");
	mid = add_struc_member(id,"EnclosingLevel",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"FilterFunc",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"HandlerFunc",	0X8,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	set_struc_align(id,2);
	
	id = get_struc_id("_EH4_SCOPETABLE");
	mid = add_struc_member(id,"GSCookieOffset",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"GSCookieXOROffset",	0X4,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"EHCookieOffset",	0X8,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"EHCookieXOROffset",	0XC,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"ScopeRecord",	0X10,	0x60000400,	get_struc_id("_EH4_SCOPETABLE_RECORD"),	0);
	set_struc_align(id,2);
	
	id = get_struc_id("_EH3_EXCEPTION_REGISTRATION");
	mid = add_struc_member(id,"Next",	0,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"ExceptionHandler",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"ScopeTable",	0X8,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"TryLevel",	0XC,	0x20000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("CPPEH_RECORD");
	mid = add_struc_member(id,"old_esp",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"exc_ptr",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"registration",	0X8,	0x60000400,	get_struc_id("_EH3_EXCEPTION_REGISTRATION"),	16);
	set_struc_align(id,2);
	
	id = get_struc_id("DATA_BLOB");
	mid = add_struc_member(id,"cbData",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"pbData",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	set_struc_align(id,2);
	
	id = get_struc_id("_RTL_CRITICAL_SECTION");
	mid = add_struc_member(id,"DebugInfo",	0,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"LockCount",	0X4,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"RecursionCount",	0X8,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"OwningThread",	0XC,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"LockSemaphore",	0X10,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"SpinCount",	0X14,	0x20000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F::$AA04DEB0C6383F89F13D312A174572A9");
	mid = add_struc_member(id,"wProcessorArchitecture",	0,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wReserved",	0X2,	0x10000400,	-1,	2);
	set_struc_align(id,1);
	
	id = get_struc_id("_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F");
	mid = add_struc_member(id,"dwOemId",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"anonymous_0",	0,	0x60000400,	get_struc_id("_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F::$AA04DEB0C6383F89F13D312A174572A9"),	4);
	set_struc_align(id,2);
	
	id = get_struc_id("_SYSTEM_INFO");
	mid = add_struc_member(id,"anonymous_0",	0,	0x60000400,	get_struc_id("_SYSTEM_INFO::$A707B71C060B6D10F73A71917EA8473F"),	4);
	mid = add_struc_member(id,"dwPageSize",	0X4,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"lpMinimumApplicationAddress",	0X8,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"lpMaximumApplicationAddress",	0XC,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"dwActiveProcessorMask",	0X10,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwNumberOfProcessors",	0X14,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwProcessorType",	0X18,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwAllocationGranularity",	0X1C,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"wProcessorLevel",	0X20,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wProcessorRevision",	0X22,	0x10000400,	-1,	2);
	set_struc_align(id,2);
	
	id = get_struc_id("_OVERLAPPED");
	mid = add_struc_member(id,"Internal",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"InternalHigh",	0X4,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"Offset",	0X8,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"OffsetHigh",	0XC,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"hEvent",	0X10,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	set_struc_align(id,2);
	
	id = get_struc_id("_FILETIME");
	mid = add_struc_member(id,"dwLowDateTime",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwHighDateTime",	0X4,	0x20000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("_LARGE_INTEGER::$837407842DC9087486FDFA5FEB63B74E");
	mid = add_struc_member(id,"LowPart",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"HighPart",	0X4,	0x20000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("LARGE_INTEGER");
	mid = add_struc_member(id,"anonymous_0",	0,	0x60000400,	get_struc_id("_LARGE_INTEGER::$837407842DC9087486FDFA5FEB63B74E"),	8);
	mid = add_struc_member(id,"u",	0,	0x60000400,	get_struc_id("_LARGE_INTEGER::$837407842DC9087486FDFA5FEB63B74E"),	8);
	mid = add_struc_member(id,"QuadPart",	0,	0x30000400,	-1,	8);
	set_struc_align(id,3);
	
	id = get_struc_id("_EXCEPTION_POINTERS");
	mid = add_struc_member(id,"ExceptionRecord",	0,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"ContextRecord",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	set_struc_align(id,2);
	
	id = get_struc_id("WSAData");
	mid = add_struc_member(id,"wVersion",	0,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wHighVersion",	0X2,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"szDescription",	0X4,	0x000400,	-1,	257);
	mid = add_struc_member(id,"szSystemStatus",	0X105,	0x000400,	-1,	129);
	mid = add_struc_member(id,"iMaxSockets",	0X186,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"iMaxUdpDg",	0X188,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"lpVendorInfo",	0X18C,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	set_struc_align(id,2);
	
	id = get_struc_id("_OSVERSIONINFOEXA");
	mid = add_struc_member(id,"dwOSVersionInfoSize",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwMajorVersion",	0X4,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwMinorVersion",	0X8,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwBuildNumber",	0XC,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwPlatformId",	0X10,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"szCSDVersion",	0X14,	0x000400,	-1,	128);
	mid = add_struc_member(id,"wServicePackMajor",	0X94,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wServicePackMinor",	0X96,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wReserved",	0X98,	0x10000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("fd_set");
	mid = add_struc_member(id,"fd_count",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"fd_array",	0X4,	0x20000400,	-1,	256);
	set_struc_align(id,2);
	
	id = get_struc_id("sockaddr");
	mid = add_struc_member(id,"sa_family",	0,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"sa_data",	0X2,	0x000400,	-1,	14);
	set_struc_align(id,1);
	
	id = get_struc_id("FILETIME");
	mid = add_struc_member(id,"dwLowDateTime",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwHighDateTime",	0X4,	0x20000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("_WIN32_FIND_DATAW");
	mid = add_struc_member(id,"dwFileAttributes",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"ftCreationTime",	0X4,	0x60000400,	get_struc_id("FILETIME"),	8);
	mid = add_struc_member(id,"ftLastAccessTime",	0XC,	0x60000400,	get_struc_id("FILETIME"),	8);
	mid = add_struc_member(id,"ftLastWriteTime",	0X14,	0x60000400,	get_struc_id("FILETIME"),	8);
	mid = add_struc_member(id,"nFileSizeHigh",	0X1C,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"nFileSizeLow",	0X20,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwReserved0",	0X24,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwReserved1",	0X28,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"cFileName",	0X2C,	0x10000400,	-1,	520);
	mid = add_struc_member(id,"cAlternateFileName",	0X234,	0x10000400,	-1,	28);
	set_struc_align(id,2);
	
	id = get_struc_id("_SYSTEMTIME");
	mid = add_struc_member(id,"wYear",	0,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wMonth",	0X2,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wDayOfWeek",	0X4,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wDay",	0X6,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wHour",	0X8,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wMinute",	0XA,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wSecond",	0XC,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wMilliseconds",	0XE,	0x10000400,	-1,	2);
	set_struc_align(id,1);
	
	id = get_struc_id("_BY_HANDLE_FILE_INFORMATION");
	mid = add_struc_member(id,"dwFileAttributes",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"ftCreationTime",	0X4,	0x60000400,	get_struc_id("FILETIME"),	8);
	mid = add_struc_member(id,"ftLastAccessTime",	0XC,	0x60000400,	get_struc_id("FILETIME"),	8);
	mid = add_struc_member(id,"ftLastWriteTime",	0X14,	0x60000400,	get_struc_id("FILETIME"),	8);
	mid = add_struc_member(id,"dwVolumeSerialNumber",	0X1C,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"nFileSizeHigh",	0X20,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"nFileSizeLow",	0X24,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"nNumberOfLinks",	0X28,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"nFileIndexHigh",	0X2C,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"nFileIndexLow",	0X30,	0x20000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("SYSTEMTIME");
	mid = add_struc_member(id,"wYear",	0,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wMonth",	0X2,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wDayOfWeek",	0X4,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wDay",	0X6,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wHour",	0X8,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wMinute",	0XA,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wSecond",	0XC,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"wMilliseconds",	0XE,	0x10000400,	-1,	2);
	set_struc_align(id,1);
	
	id = get_struc_id("_TIME_ZONE_INFORMATION");
	mid = add_struc_member(id,"Bias",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"StandardName",	0X4,	0x10000400,	-1,	64);
	mid = add_struc_member(id,"StandardDate",	0X44,	0x60000400,	get_struc_id("SYSTEMTIME"),	16);
	mid = add_struc_member(id,"StandardBias",	0X54,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"DaylightName",	0X58,	0x10000400,	-1,	64);
	mid = add_struc_member(id,"DaylightDate",	0X98,	0x60000400,	get_struc_id("SYSTEMTIME"),	16);
	mid = add_struc_member(id,"DaylightBias",	0XA8,	0x20000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("_cpinfo");
	mid = add_struc_member(id,"MaxCharSize",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"DefaultChar",	0X4,	0x000400,	-1,	2);
	mid = add_struc_member(id,"LeadByte",	0X6,	0x000400,	-1,	12);
	set_struc_align(id,2);
	
	id = get_struc_id("SINGLE_LIST_ENTRY");
	mid = add_struc_member(id,"Next",	0,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	set_struc_align(id,2);
	
	id = get_struc_id("_SLIST_HEADER::$83AF6D9DC8E3B10431D79B304957BA23");
	mid = add_struc_member(id,"Next",	0,	0x60000400,	get_struc_id("SINGLE_LIST_ENTRY"),	4);
	mid = add_struc_member(id,"Depth",	0X4,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"Sequence",	0X6,	0x10000400,	-1,	2);
	set_struc_align(id,2);
	
	id = get_struc_id("_SLIST_HEADER");
	mid = add_struc_member(id,"Alignment",	0,	0x30000400,	-1,	8);
	mid = add_struc_member(id,"s",	0,	0x60000400,	get_struc_id("_SLIST_HEADER::$83AF6D9DC8E3B10431D79B304957BA23"),	8);
	set_struc_align(id,3);
	
	id = get_struc_id("_STARTUPINFOW");
	mid = add_struc_member(id,"cb",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"lpReserved",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"lpDesktop",	0X8,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"lpTitle",	0XC,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"dwX",	0X10,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwY",	0X14,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwXSize",	0X18,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwYSize",	0X1C,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwXCountChars",	0X20,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwYCountChars",	0X24,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwFillAttribute",	0X28,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwFlags",	0X2C,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"wShowWindow",	0X30,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"cbReserved2",	0X32,	0x10000400,	-1,	2);
	mid = add_struc_member(id,"lpReserved2",	0X34,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"hStdInput",	0X38,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"hStdOutput",	0X3C,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"hStdError",	0X40,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	set_struc_align(id,2);
	
	id = get_struc_id("_SECURITY_ATTRIBUTES");
	mid = add_struc_member(id,"nLength",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"lpSecurityDescriptor",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"bInheritHandle",	0X8,	0x20000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("ADDRINFOA");
	mid = add_struc_member(id,"ai_flags",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"ai_family",	0X4,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"ai_socktype",	0X8,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"ai_protocol",	0XC,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"ai_addrlen",	0X10,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"ai_canonname",	0X14,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"ai_addr",	0X18,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"ai_next",	0X1C,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	set_struc_align(id,2);
	
	id = get_struc_id("FuncInfo");
	mid = add_struc_member(id,"magicNumber",	0,	0x21100400,	-1,	4);
	mid = add_struc_member(id,"maxState",	0X4,	0x22200400,	-1,	4);
	mid = add_struc_member(id,"pUnwindMap",	0X8,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"nTryBlocks",	0XC,	0x22200400,	-1,	4);
	mid = add_struc_member(id,"pTryBlockMap",	0X10,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"nIPMapEntries",	0X14,	0x22200400,	-1,	4);
	mid = add_struc_member(id,"pIPtoStateMap",	0X18,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"pESTypeList",	0X1C,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"EHFlags",	0X20,	0x21100400,	-1,	4);
	
	id = get_struc_id("UnwindMapEntry");
	mid = add_struc_member(id,"toState",	0,	0x22200400,	-1,	4);
	mid = add_struc_member(id,"action",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	
	id = get_struc_id("TryBlockMapEntry");
	mid = add_struc_member(id,"tryLow",	0,	0x22200400,	-1,	4);
	mid = add_struc_member(id,"tryHigh",	0X4,	0x22200400,	-1,	4);
	mid = add_struc_member(id,"catchHigh",	0X8,	0x22200400,	-1,	4);
	mid = add_struc_member(id,"nCatches",	0XC,	0x22200400,	-1,	4);
	mid = add_struc_member(id,"pHandlerArray",	0X10,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	
	id = get_struc_id("HandlerType");
	mid = add_struc_member(id,"adjectives",	0,	0x21100400,	-1,	4);
	mid = add_struc_member(id,"pType",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"dispCatchObj",	0X8,	0x22200400,	-1,	4);
	mid = add_struc_member(id,"addressOfHandler",	0XC,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	
	id = get_struc_id("JSON_Value_Value");
	mid = add_struc_member(id,"string",	0,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"number",	0,	0x90000400,	-1,	8);
	mid = add_struc_member(id,"object",	0,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"array",	0,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"boolean",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"null",	0,	0x20000400,	-1,	4);
	set_struc_align(id,3);
	
	id = get_struc_id("JSON_Value");
	mid = add_struc_member(id,"type",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"value",	0X8,	0x60000400,	get_struc_id("JSON_Value_Value"),	8);
	set_struc_align(id,3);
	
	id = get_struc_id("JSON_Object");
	mid = add_struc_member(id,"names",	0,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"values",	0X4,	0x25500400,	0XFFFFFFFF,	4,	0XFFFFFFFF,	0,	0x000002);
	mid = add_struc_member(id,"count",	0X8,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"capacity",	0XC,	0x20000400,	-1,	4);
	set_struc_align(id,2);
	
	id = get_struc_id("__m128i");
	mid = add_struc_member(id,"m128i_i8",	0,	0x000400,	-1,	16);
	mid = add_struc_member(id,"m128i_i16",	0,	0x10000400,	-1,	16);
	mid = add_struc_member(id,"m128i_i32",	0,	0x20000400,	-1,	16);
	mid = add_struc_member(id,"m128i_i64",	0,	0x30000400,	-1,	16);
	mid = add_struc_member(id,"m128i_u8",	0,	0x000400,	-1,	16);
	mid = add_struc_member(id,"m128i_u16",	0,	0x10000400,	-1,	16);
	mid = add_struc_member(id,"m128i_u32",	0,	0x20000400,	-1,	16);
	mid = add_struc_member(id,"m128i_u64",	0,	0x30000400,	-1,	16);
	set_struc_align(id,4);
	
	id = get_struc_id("_WIN32_FIND_DATAA");
	mid = add_struc_member(id,"dwFileAttributes",	0,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"ftCreationTime",	0X4,	0x60000400,	get_struc_id("FILETIME"),	8);
	mid = add_struc_member(id,"ftLastAccessTime",	0XC,	0x60000400,	get_struc_id("FILETIME"),	8);
	mid = add_struc_member(id,"ftLastWriteTime",	0X14,	0x60000400,	get_struc_id("FILETIME"),	8);
	mid = add_struc_member(id,"nFileSizeHigh",	0X1C,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"nFileSizeLow",	0X20,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwReserved0",	0X24,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"dwReserved1",	0X28,	0x20000400,	-1,	4);
	mid = add_struc_member(id,"cFileName",	0X2C,	0x000400,	-1,	260);
	mid = add_struc_member(id,"cAlternateFileName",	0X130,	0x000400,	-1,	14);
	set_struc_align(id,2);
	return id;
}

//------------------------------------------------------------------------
// Information about structure types

static Structures(void) {
        auto id;
        begin_type_updating(UTP_STRUCT);
	id = Structures_0(id);
        end_type_updating(UTP_STRUCT);
}

// End of file.
